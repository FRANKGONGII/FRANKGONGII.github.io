<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>OPCUA open62541-包接收流程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="open62541的实现如果消息太大怎么处理？ 调用流程： sendResponse()：其余处理全部完毕，调用UA_MessageContext_finish(&amp;message_content); UA_MessageContext_finish()：返回sendSymmetricChunk(mc) sendSymmetricChunk()：内部检查adjustCheckMessageL">
<meta property="og:type" content="article">
<meta property="og:title" content="OPCUA open62541-包接收流程">
<meta property="og:url" content="http://example.com/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="open62541的实现如果消息太大怎么处理？ 调用流程： sendResponse()：其余处理全部完毕，调用UA_MessageContext_finish(&amp;message_content); UA_MessageContext_finish()：返回sendSymmetricChunk(mc) sendSymmetricChunk()：内部检查adjustCheckMessageL">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/mOPC_%E5%8C%85%E6%8E%A5%E6%94%B6.png">
<meta property="article:published_time" content="2024-11-07T05:36:05.000Z">
<meta property="article:modified_time" content="2024-12-13T08:59:12.435Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/mOPC_%E5%8C%85%E6%8E%A5%E6%94%B6.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-OPCUA-open62541包接收流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-11-07T05:36:05.000Z" itemprop="datePublished">2024-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>►<a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/">baosight</a>►<a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/OPC-UA/">OPC_UA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      OPCUA open62541-包接收流程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="open62541的实现"><a href="#open62541的实现" class="headerlink" title="open62541的实现"></a>open62541的实现</h1><h2 id="如果消息太大怎么处理？"><a href="#如果消息太大怎么处理？" class="headerlink" title="如果消息太大怎么处理？"></a>如果消息太大怎么处理？</h2><ul>
<li>调用流程：<ol>
<li>sendResponse()：其余处理全部完毕，调用UA_MessageContext_finish(&amp;message_content);</li>
<li>UA_MessageContext_finish()：返回sendSymmetricChunk(mc)</li>
<li>sendSymmetricChunk()：内部检查adjustCheckMessageLimitsSym(mc, bodyLength);</li>
<li>adjustCheckMessageLimitsSym()：返回状态码</li>
</ol>
</li>
</ul>
<h2 id="接收包的流程"><a href="#接收包的流程" class="headerlink" title="接收包的流程"></a>接收包的流程</h2><ul>
<li>这个是按目前的理解设计的实现<br><img src="/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/mOPC_%E5%8C%85%E6%8E%A5%E6%94%B6.png"></li>
<li>在包接收 &amp; 处理的流程上，open62541采取的方案是每次把缓冲区存满，提取完整包，保存不完整包下次用</li>
</ul>
<h2 id="接收包的流程-1"><a href="#接收包的流程-1" class="headerlink" title="接收包的流程"></a>接收包的流程</h2><ol>
<li><p>入口函数：UA_SecureChannel_processBuffer：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">UA_StatusCode</span><br><span class="line"><span class="title function_">UA_SecureChannel_processBuffer</span><span class="params">(UA_SecureChannel *channel, <span class="type">void</span> *application,</span></span><br><span class="line"><span class="params">                              UA_ProcessMessageCallback callback,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> UA_ByteString *buffer)</span> &#123;</span><br><span class="line">    <span class="comment">/* Prepend the incomplete last chunk. This is usually done in the</span></span><br><span class="line"><span class="comment">    * networklayer. But we test for a buffered incomplete chunk here again to</span></span><br><span class="line"><span class="comment">    * work around &quot;lazy&quot; network layers. */</span></span><br><span class="line">    <span class="comment">// 先看有没有之前保存的不完整的包，如果有，append到buffer前面</span></span><br><span class="line">    UA_ByteString appended = channel-&gt;incompleteChunk;</span><br><span class="line">    <span class="keyword">if</span>(appended.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        channel-&gt;incompleteChunk = UA_BYTESTRING_NULL;</span><br><span class="line">        UA_Byte *t = (UA_Byte*)UA_realloc(appended.data, appended.length + buffer-&gt;length);</span><br><span class="line">        UA_CHECK_MEM(t, UA_ByteString_clear(&amp;appended);</span><br><span class="line">                    <span class="keyword">return</span> UA_STATUSCODE_BADOUTOFMEMORY);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;t[appended.length], buffer-&gt;data, buffer-&gt;length);</span><br><span class="line">        appended.data = t;</span><br><span class="line">        appended.length += buffer-&gt;length;</span><br><span class="line">        buffer = &amp;appended;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop over the received chunks */</span></span><br><span class="line">    <span class="comment">// 循环，extractCompleteChunk()直到能提取一个完整的包</span></span><br><span class="line">    <span class="type">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    UA_Boolean done = <span class="literal">false</span>;</span><br><span class="line">    UA_StatusCode res;</span><br><span class="line">    <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">        res = extractCompleteChunk(channel, buffer, &amp;offset, &amp;done);</span><br><span class="line">        UA_CHECK_STATUS(res, <span class="keyword">goto</span> cleanup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer half-received chunk. Before processing the messages so that</span></span><br><span class="line"><span class="comment">    * processing is reentrant. */</span></span><br><span class="line">    <span class="comment">// 如果完整包后面还有数据，提取到不完整包</span></span><br><span class="line">    <span class="keyword">if</span>(offset &lt; buffer-&gt;length) &#123;</span><br><span class="line">        res = persistIncompleteChunk(channel, buffer, offset);</span><br><span class="line">        UA_CHECK_STATUS(res, <span class="keyword">goto</span> cleanup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process whatever we can. Chunks of completed and processed messages are</span></span><br><span class="line"><span class="comment">    * removed. */</span></span><br><span class="line">    <span class="comment">// 调用processChunks()处理包</span></span><br><span class="line">    res = processChunks(channel, application, callback);</span><br><span class="line">    UA_CHECK_STATUS(res, <span class="keyword">goto</span> cleanup);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Persist full chunks that still point to the buffer. Can only return</span></span><br><span class="line"><span class="comment">    * UA_STATUSCODE_BADOUTOFMEMORY as an error code. So merging res works. */</span></span><br><span class="line">    res |= persistCompleteChunks(&amp;channel-&gt;completeChunks);</span><br><span class="line">    res |= persistCompleteChunks(&amp;channel-&gt;decryptedChunks);</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    UA_ByteString_clear(&amp;appended);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>提取完整包函数：extractCompleteChunk()</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> UA_StatusCode</span><br><span class="line"><span class="title function_">extractCompleteChunk</span><span class="params">(UA_SecureChannel *channel, <span class="type">const</span> UA_ByteString *buffer,</span></span><br><span class="line"><span class="params">                    <span class="type">size_t</span> *offset, UA_Boolean *done)</span> &#123;</span><br><span class="line">    <span class="comment">/* At least 8 byte needed for the header. Wait for the next chunk. */</span></span><br><span class="line">    <span class="comment">// 判断是否有足够的数据用于提取包</span></span><br><span class="line">    <span class="type">size_t</span> initial_offset = *offset;</span><br><span class="line">    <span class="type">size_t</span> remaining = buffer-&gt;length - initial_offset;</span><br><span class="line">    <span class="keyword">if</span>(remaining &lt; UA_SECURECHANNEL_MESSAGEHEADER_LENGTH) &#123;</span><br><span class="line">        *done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> UA_STATUSCODE_GOOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Decoding cannot fail */</span></span><br><span class="line">    <span class="comment">// 解析消息头，只有MSGType和ChunkType？</span></span><br><span class="line">    UA_TcpMessageHeader hdr;</span><br><span class="line">    UA_StatusCode res =</span><br><span class="line">        UA_decodeBinaryInternal(buffer, &amp;initial_offset, &amp;hdr,</span><br><span class="line">                                &amp;UA_TRANSPORT[UA_TRANSPORT_TCPMESSAGEHEADER], <span class="literal">NULL</span>);</span><br><span class="line">    UA_assert(res == UA_STATUSCODE_GOOD);</span><br><span class="line">    (<span class="type">void</span>)res; <span class="comment">/* pacify compilers if assert is ignored */</span></span><br><span class="line">    UA_MessageType msgType = (UA_MessageType)</span><br><span class="line">        (hdr.messageTypeAndChunkType &amp; UA_BITMASK_MESSAGETYPE);</span><br><span class="line">    UA_ChunkType chunkType = (UA_ChunkType)</span><br><span class="line">        (hdr.messageTypeAndChunkType &amp; UA_BITMASK_CHUNKTYPE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查消息大小是否合法</span></span><br><span class="line">    <span class="keyword">if</span>(hdr.messageSize &lt; UA_SECURECHANNEL_MESSAGE_MIN_LENGTH)</span><br><span class="line">        <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line">    <span class="keyword">if</span>(hdr.messageSize &gt; channel-&gt;config.recvBufferSize)</span><br><span class="line">        <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETOOLARGE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不完整的消息，直接返回等待下一步处理</span></span><br><span class="line">    <span class="keyword">if</span>(hdr.messageSize &gt; remaining) &#123;</span><br><span class="line">        *done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> UA_STATUSCODE_GOOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包的数据</span></span><br><span class="line">    UA_ByteString chunkPayload;</span><br><span class="line">    chunkPayload.data = &amp;buffer-&gt;data[*offset];</span><br><span class="line">    chunkPayload.length = hdr.messageSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有MSG可以有多个包</span></span><br><span class="line">    <span class="keyword">if</span>(msgType == UA_MESSAGETYPE_RHE || msgType == UA_MESSAGETYPE_HEL || msgType == UA_MESSAGETYPE_ACK ||</span><br><span class="line">      msgType == UA_MESSAGETYPE_ERR || msgType == UA_MESSAGETYPE_OPN) &#123;</span><br><span class="line">        <span class="keyword">if</span>(chunkType != UA_CHUNKTYPE_FINAL)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Only messages on SecureChannel-level with symmetric encryption afterwards */</span></span><br><span class="line">        <span class="comment">// 加密相关的检查</span></span><br><span class="line">        <span class="keyword">if</span>(msgType != UA_MESSAGETYPE_MSG &amp;&amp;</span><br><span class="line">          msgType != UA_MESSAGETYPE_CLO)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check the chunk type before decrypting */</span></span><br><span class="line">        <span class="keyword">if</span>(chunkType != UA_CHUNKTYPE_FINAL &amp;&amp;</span><br><span class="line">          chunkType != UA_CHUNKTYPE_INTERMEDIATE &amp;&amp;</span><br><span class="line">          chunkType != UA_CHUNKTYPE_ABORT)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the chunk; forward the offset */</span></span><br><span class="line">    <span class="comment">// 移动处理指针，新建chunk并加入完整队列，注意这时候还没有解析</span></span><br><span class="line">    *offset += hdr.messageSize;</span><br><span class="line">    UA_Chunk *chunk = (UA_Chunk*)UA_malloc(<span class="keyword">sizeof</span>(UA_Chunk));</span><br><span class="line">    UA_CHECK_MEM(chunk, <span class="keyword">return</span> UA_STATUSCODE_BADOUTOFMEMORY);</span><br><span class="line"></span><br><span class="line">    chunk-&gt;bytes = chunkPayload;</span><br><span class="line">    chunk-&gt;messageType = msgType;</span><br><span class="line">    chunk-&gt;chunkType = chunkType;</span><br><span class="line">    chunk-&gt;requestId = <span class="number">0</span>;</span><br><span class="line">    chunk-&gt;copied = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    SIMPLEQ_INSERT_TAIL(&amp;channel-&gt;completeChunks, chunk, pointers);</span><br><span class="line">    <span class="keyword">return</span> UA_STATUSCODE_GOOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>Chunk处理：processChunks()</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Processes chunks and puts them into the payloads queue. Once a final chunk is</span></span><br><span class="line"><span class="comment">* put into the queue, the message is assembled and the callback is called. The</span></span><br><span class="line"><span class="comment">* queue will be cleared for the next message. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> UA_StatusCode</span><br><span class="line"><span class="title function_">processChunks</span><span class="params">(UA_SecureChannel *channel, <span class="type">void</span> *application,</span></span><br><span class="line"><span class="params">              UA_ProcessMessageCallback callback)</span> &#123;</span><br><span class="line">    UA_Chunk *chunk;</span><br><span class="line">    UA_StatusCode res = UA_STATUSCODE_GOOD;</span><br><span class="line">    <span class="comment">// 逐个取出完整的chunk</span></span><br><span class="line">    <span class="keyword">while</span>((chunk = SIMPLEQ_FIRST(&amp;channel-&gt;completeChunks))) &#123;</span><br><span class="line">        <span class="comment">/* Remove from the complete-chunk queue */</span></span><br><span class="line">        <span class="comment">// 把这个chunk从队列中移除</span></span><br><span class="line">        SIMPLEQ_REMOVE_HEAD(&amp;channel-&gt;completeChunks, pointers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check, decrypt and unpack the payload */</span></span><br><span class="line">        <span class="comment">// 检查，解密和解码</span></span><br><span class="line">        <span class="keyword">if</span>(chunk-&gt;messageType == UA_MESSAGETYPE_OPN) &#123;</span><br><span class="line">            <span class="keyword">if</span>(channel-&gt;state != UA_SECURECHANNELSTATE_OPEN &amp;&amp;</span><br><span class="line">              channel-&gt;state != UA_SECURECHANNELSTATE_OPN_SENT &amp;&amp;</span><br><span class="line">              channel-&gt;state != UA_SECURECHANNELSTATE_ACK_SENT)</span><br><span class="line">                res = UA_STATUSCODE_BADINVALIDSTATE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res = unpackPayloadOPN(channel, chunk, application);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(chunk-&gt;messageType == UA_MESSAGETYPE_MSG ||</span><br><span class="line">                  chunk-&gt;messageType == UA_MESSAGETYPE_CLO) &#123;</span><br><span class="line">            <span class="keyword">if</span>(channel-&gt;state == UA_SECURECHANNELSTATE_CLOSED)</span><br><span class="line">                res = UA_STATUSCODE_BADSECURECHANNELCLOSED;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res = unpackPayloadMSG(channel, chunk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chunk-&gt;bytes.data += UA_SECURECHANNEL_MESSAGEHEADER_LENGTH;</span><br><span class="line">            chunk-&gt;bytes.length -= UA_SECURECHANNEL_MESSAGEHEADER_LENGTH;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res != UA_STATUSCODE_GOOD) &#123;</span><br><span class="line">            UA_Chunk_delete(chunk);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Add to the decrypted-chunk queue */</span></span><br><span class="line">        <span class="comment">// 已经解密的数据块添加到 decryptedChunks 队列</span></span><br><span class="line">        SIMPLEQ_INSERT_TAIL(&amp;channel-&gt;decryptedChunks, chunk, pointers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check the resource limits */</span></span><br><span class="line">        channel-&gt;decryptedChunksCount++;</span><br><span class="line">        channel-&gt;decryptedChunksLength += chunk-&gt;bytes.length;</span><br><span class="line">        <span class="keyword">if</span>((channel-&gt;config.localMaxChunkCount != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            channel-&gt;decryptedChunksCount &gt; channel-&gt;config.localMaxChunkCount) ||</span><br><span class="line">          (channel-&gt;config.localMaxMessageSize != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            channel-&gt;decryptedChunksLength &gt; channel-&gt;config.localMaxMessageSize)) &#123;</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETOOLARGE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Waiting for additional chunks */</span></span><br><span class="line">        <span class="comment">// 关键，如果不是最终块，跳过后面的过程并等待新的包</span></span><br><span class="line">        <span class="comment">// 问题：这里是如何驱动的？？？</span></span><br><span class="line">        <span class="keyword">if</span>(chunk-&gt;chunkType == UA_CHUNKTYPE_INTERMEDIATE)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Final chunk or abort. Reset the counters. */</span></span><br><span class="line">        channel-&gt;decryptedChunksCount = <span class="number">0</span>;</span><br><span class="line">        channel-&gt;decryptedChunksLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort the message, remove all decrypted chunks</span></span><br><span class="line"><span class="comment">        * <span class="doctag">TODO:</span> Log a warning with the error code */</span></span><br><span class="line">        <span class="keyword">if</span>(chunk-&gt;chunkType == UA_CHUNKTYPE_ABORT) &#123;</span><br><span class="line">            <span class="keyword">while</span>((chunk = SIMPLEQ_FIRST(&amp;channel-&gt;decryptedChunks))) &#123;</span><br><span class="line">                SIMPLEQ_REMOVE_HEAD(&amp;channel-&gt;decryptedChunks, pointers);</span><br><span class="line">                UA_Chunk_delete(chunk);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The decrypted queue contains a full message. Process it. */</span></span><br><span class="line">        <span class="comment">// 组装块，处理+发送！</span></span><br><span class="line">        UA_assert(chunk-&gt;chunkType == UA_CHUNKTYPE_FINAL);</span><br><span class="line">        res = assembleProcessMessage(channel, application, callback);</span><br><span class="line">        UA_CHECK_STATUS(res, <span class="keyword">return</span> res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UA_STATUSCODE_GOOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组装块：assembleProcessMessage()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> UA_StatusCode</span><br><span class="line"><span class="title function_">assembleProcessMessage</span><span class="params">(UA_SecureChannel *channel, <span class="type">void</span> *application,</span></span><br><span class="line"><span class="params">                    UA_ProcessMessageCallback callback)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得解密队列的第一个块</span></span><br><span class="line">    UA_Chunk *chunk = SIMPLEQ_FIRST(&amp;channel-&gt;decryptedChunks);</span><br><span class="line">    UA_assert(chunk != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    UA_StatusCode res = UA_STATUSCODE_GOOD;</span><br><span class="line">    <span class="comment">// 如果是Final块，那么就可以直接调用callback了</span></span><br><span class="line">    <span class="keyword">if</span>(chunk-&gt;chunkType == UA_CHUNKTYPE_FINAL) &#123;</span><br><span class="line">        SIMPLEQ_REMOVE_HEAD(&amp;channel-&gt;decryptedChunks, pointers);</span><br><span class="line">        UA_assert(chunk-&gt;chunkType == UA_CHUNKTYPE_FINAL);</span><br><span class="line">        res = callback(application, channel, chunk-&gt;messageType,</span><br><span class="line">                    chunk-&gt;requestId, &amp;chunk-&gt;bytes);</span><br><span class="line">        UA_Chunk_delete(chunk);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是Final块，那么获取到requestId等信息，用于检查解密队列中的其他块</span></span><br><span class="line">    UA_UInt32 requestId = chunk-&gt;requestId;</span><br><span class="line">    UA_MessageType messageType = chunk-&gt;messageType;</span><br><span class="line">    UA_ChunkType chunkType = chunk-&gt;chunkType;</span><br><span class="line">    UA_assert(chunkType == UA_CHUNKTYPE_INTERMEDIATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Q：怎么保证解密队列里都是这个requestId的块？如果有多个client连接并分包发送，怎么办？？？</span></span><br><span class="line">    <span class="comment">// A：channel是一个client独有的。顺序是通过TCP的消息按序到达实现的，保证是有序的</span></span><br><span class="line">    <span class="type">size_t</span> messageSize = <span class="number">0</span>;</span><br><span class="line">    SIMPLEQ_FOREACH(chunk, &amp;channel-&gt;decryptedChunks, pointers) &#123;</span><br><span class="line">        <span class="comment">/* Consistency check */</span></span><br><span class="line">        <span class="keyword">if</span>(requestId != chunk-&gt;requestId)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADINTERNALERROR;</span><br><span class="line">        <span class="keyword">if</span>(chunkType != chunk-&gt;chunkType &amp;&amp; chunk-&gt;chunkType != UA_CHUNKTYPE_FINAL)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line">        <span class="keyword">if</span>(chunk-&gt;messageType != messageType)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Sum up the lengths */</span></span><br><span class="line">        messageSize += chunk-&gt;bytes.length;</span><br><span class="line">        <span class="keyword">if</span>(chunk-&gt;chunkType == UA_CHUNKTYPE_FINAL)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate memory for the full message */</span></span><br><span class="line">    <span class="comment">// 用计算的大小分配空间</span></span><br><span class="line">    UA_ByteString payload;</span><br><span class="line">    res = UA_ByteString_allocBuffer(&amp;payload, messageSize);</span><br><span class="line">    UA_CHECK_STATUS(res, <span class="keyword">return</span> res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assemble the full message */</span></span><br><span class="line">    <span class="comment">// 合并data</span></span><br><span class="line">    <span class="type">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        chunk = SIMPLEQ_FIRST(&amp;channel-&gt;decryptedChunks);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;payload.data[offset], chunk-&gt;bytes.data, chunk-&gt;bytes.length);</span><br><span class="line">        offset += chunk-&gt;bytes.length;</span><br><span class="line">        SIMPLEQ_REMOVE_HEAD(&amp;channel-&gt;decryptedChunks, pointers);</span><br><span class="line">        UA_ChunkType ct = chunk-&gt;chunkType;</span><br><span class="line">        UA_Chunk_delete(chunk);</span><br><span class="line">        <span class="keyword">if</span>(ct == UA_CHUNKTYPE_FINAL)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process the assembled message */</span></span><br><span class="line">    res = callback(application, channel, messageType, requestId, &amp;payload);</span><br><span class="line">    UA_ByteString_clear(&amp;payload);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="两个处理方案的区别："><a href="#两个处理方案的区别：" class="headerlink" title="两个处理方案的区别："></a>两个处理方案的区别：</h2><ol>
<li>接收包上：我们的方案是以获取完整包为最优先，逻辑是获取完整包，完毕后如果有剩下的数据，继续尝试获取对于它获得完整包。open62541是每次读满缓存区，先检查有没有之前获得的不完整的包，如果有就加到缓存区前面，形成完整包并先处理。然后尝试获取完整包并处理，最后看看缓存区后面有没有不完整的包</li>
</ol>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="改为分包后订阅失败"><a href="#改为分包后订阅失败" class="headerlink" title="改为分包后订阅失败"></a>改为分包后订阅失败</h3><ul>
<li>browser主动发了一个closeSecureChannel请求，然后连接重建，由于暂时没有实现republish，订阅失败<ul>
<li>类似的现象：<a target="_blank" rel="noopener" href="https://opcfoundation.org/forum/opc-ua-standard/opc-ua-client-suddenly-stops-creating-publish-requests-and-eventually-closes-secure-channel-to-server/">https://opcfoundation.org/forum/opc-ua-standard/opc-ua-client-suddenly-stops-creating-publish-requests-and-eventually-closes-secure-channel-to-server/</a></li>
<li>用wireshark抓包之后发现确实有一个readrequest请求没有回复？？timeout是10000ms，也就是10s，也的确是在大约10s后browser发出了close请求，看来确实可能是因为没有回复这个请求导致的</li>
</ul>
</li>
<li>问题定位到了，是没有处理粘包。。。</li>
</ul>
<h2 id="分包发送"><a href="#分包发送" class="headerlink" title="分包发送"></a>分包发送</h2><p>TCP_sendWithConnection</p>
<h1 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h1><h2 id="分包接收"><a href="#分包接收" class="headerlink" title="分包接收"></a>分包接收</h2><ul>
<li>TCPServer<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ServerImpl::Listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> MAX_BUFFER = <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">    mListenFd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mListenFd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr, clientAddr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(mListenFd, (<span class="keyword">struct</span> socketaddr*)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// bind fail</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">listen</span>(mListenFd, <span class="number">10</span>);</span><br><span class="line">    mEpollFd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mEpollFd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event, events[MAX_EVENT_NUM];</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    event.data.fd = mListenFd;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(mEpollFd, EPOLL_CTL_ADD, mListenFd, &amp;event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> eventCounts = <span class="built_in">epoll_wait</span>(mEpollFd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCounts; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == mListenFd) &#123;</span><br><span class="line">                <span class="comment">// 处理新链接</span></span><br><span class="line">                <span class="type">socklen_t</span> clientLen = <span class="built_in">sizeof</span>(clientAddr);</span><br><span class="line">                <span class="keyword">auto</span> clientFd = <span class="built_in">accept</span>(mListenFd, (<span class="keyword">struct</span> socketaddr*)&amp;clientAddr, &amp;clientLen);</span><br><span class="line">                event.events = EPOLLIN;</span><br><span class="line">                event.data.fd = clientFd;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(mEpollFd, EPOLL_CTL_ADD, clientFd, &amp;event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 接收消息，此处省略timeManager的情况</span></span><br><span class="line">                <span class="keyword">auto</span> clientFd = events[i].data.fd;</span><br><span class="line">                <span class="type">char</span> buffer[MAX_BUFFER] = &#123;&#125;;</span><br><span class="line">                <span class="keyword">auto</span> bytes = <span class="built_in">recv</span>(clientFd, buffer, MAX_BUFFER, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (bytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.<span class="built_in">DeleteFdByEpoll</span>(clientFd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">processBuffer</span>(clientFd, bytes, buffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPServerImpl::processBuffer</span><span class="params">(<span class="type">int</span> clientFd, <span class="type">int</span> bytes, <span class="type">char</span> *buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bytes &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// 至少要8字节才能开始处理</span></span><br><span class="line">        <span class="built_in">getEnoughBytes</span>(buffer, clientFd, bytes, <span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// messageLength是这个报文的大小，bytes是当前缓冲区的字节数目</span></span><br><span class="line">        <span class="type">int</span> messageLength = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 前4个字节是MSG F，报文类型和isFinal</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;messageLength, buffer + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">getEnoughBytes</span>(buffer, clientFd, bytes, messageLength);</span><br><span class="line">        <span class="type">bool</span> ifSubPack = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (buffer[<span class="number">3</span>] == <span class="string">&#x27;C&#x27;</span> &amp;&amp; buffer[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 中间包(都是完整的)放入待处理队列</span></span><br><span class="line">            UAChunk newChunk;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_BUFFER; i++) &#123;</span><br><span class="line">                newChunk.mbytes.<span class="built_in">push_back</span>(buffer[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unPackLoadMSG</span>(newChunk, clientFd, buffer, messageLength);</span><br><span class="line">            completeChunks[client].<span class="built_in">push_back</span>(newChunk);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">processChunk</span>(buffer, messageLength, clientFd, bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">endProcessBuffer</span>(clientFd, bytes, buffer, messageLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPServerImpl::getEnoughBytes</span><span class="params">(<span class="type">char</span> *buffer, <span class="type">int</span> clientFd, <span class="type">int</span> &amp;nowBytes, <span class="type">int</span> requireBytes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已经可以满足要求</span></span><br><span class="line">    <span class="keyword">if</span> (nowBytes &gt;= requireBytes) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一致循环读取直到满足数目要求</span></span><br><span class="line">    <span class="keyword">while</span> (nowBytes &lt; requireByes) &#123;</span><br><span class="line">        nowBytes += <span class="built_in">recv</span>(clientFd, buffer + nowBytes, reqiureBytes - nowBytes, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPServerImpl::processChunk</span><span class="params">(<span class="type">char</span> *buffer, <span class="type">int</span> messageLength, <span class="type">int</span> clientFd, <span class="type">int</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到了F包，开始处理一个完整包</span></span><br><span class="line">    UAChunk chunk;</span><br><span class="line">    chunk.mbytes.<span class="built_in">resize</span>(messageLength);</span><br><span class="line">    <span class="built_in">memcpy</span>(chunk.mbytes.<span class="built_in">data</span>(), buffer, messageLength);</span><br><span class="line">    <span class="keyword">if</span> (buffer[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">unPackLoadMSG</span>(chunk, clientFd, buffer, messageLength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assembleAndSendChunk</span>(chunk, clientFd, buffer, messageLength);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unPackLoadMSG</span><span class="params">(UAChunk &amp;chunk, <span class="type">int</span> clientFd, <span class="type">char</span> *buffer, <span class="type">int</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析MSG类型的消息</span></span><br><span class="line">    ChunkMessageHeader messageHeader;</span><br><span class="line">    <span class="keyword">auto</span> messageHeaderPtr = &amp;messageHeader;</span><br><span class="line">    <span class="built_in">Deserialize</span>(messageHeaderPtr, chunk.mbytes);</span><br><span class="line">    ChunkSequenceHeader sequenceHeader;</span><br><span class="line">    <span class="keyword">auto</span> sequenceHeaderPtr = &amp;sequenceHeader;</span><br><span class="line">    <span class="keyword">if</span> (channelType[messageHeaderPtr-&gt;<span class="built_in">GetSecureChannelId</span>()] &gt; NONE) &#123;</span><br><span class="line">        <span class="comment">// 没加密</span></span><br><span class="line">        <span class="built_in">Deserialize</span>(sequenceHeaderPtr, chunk.mbytes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有加密，需要用对称秘钥解密</span></span><br><span class="line">        std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="built_in">input</span>(bytes, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(input.<span class="built_in">data</span>(), buffer, bytes);</span><br><span class="line">        <span class="comment">// 要提前加载秘钥</span></span><br><span class="line">        gChannelContext[clientFd]-&gt;<span class="built_in">DecryptAndVerifySign</span>(input);</span><br><span class="line">        chunk.mbytes.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 不要messageHeader了，前面已经拿出来了</span></span><br><span class="line">        chunk.mbytes.<span class="built_in">resize</span>(input.<span class="built_in">size</span>() - <span class="number">16</span>);</span><br><span class="line">        std::<span class="built_in">copy</span>(input.<span class="built_in">begin</span>() + <span class="number">16</span>, input.<span class="built_in">end</span>(), chunk.mbytes.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="built_in">Deserialize</span>(sequenceHeaderPtr, chunk.mbytes);</span><br><span class="line">    &#125;</span><br><span class="line">    chunk.mMessageHeader = messageHeader;</span><br><span class="line">    chunk.mSequenceHeader = sequenceHeader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assembleAndSendChunk</span><span class="params">(UAChunk &amp;chunk, <span class="type">int</span> clientFd, <span class="type">char</span> *buffer, <span class="type">int</span> messageLength)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sameMessageCount = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; mergechunk;</span><br><span class="line">    <span class="keyword">if</span> (chunk.mMessageHeader.<span class="built_in">GetType0</span>() == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">int</span> nowRequestId = chunk.mSequenceHeader.<span class="built_in">GetRequestId</span>();</span><br><span class="line">        <span class="comment">// 遍历完整包队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = completeChunks[clientFd].<span class="built_in">begin</span>(); it != completeChunks[clientFd].<span class="built_in">end</span>();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nowRequestId == it-&gt;mSequenceHeader.<span class="built_in">GetRequestId</span>()) &#123;</span><br><span class="line">                sameMessageCount++;</span><br><span class="line">                decryptedChunks[clientFd].<span class="built_in">push_back</span>(*it);</span><br><span class="line">                completeChunks[clientFd].<span class="built_in">erase</span>(*it);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                it++;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// 这里是不是有点问题</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并分包数据</span></span><br><span class="line">        std::<span class="built_in">sort</span>(decryptedChunks[clientFd].<span class="built_in">begin</span>(), decryptedChunks[clientFd].<span class="built_in">end</span>(), compareChunk);</span><br><span class="line">        <span class="comment">// 加入以前的包</span></span><br><span class="line">        <span class="keyword">for</span> (UAChunk chunk : decryptedChunks[clientFd]) &#123;</span><br><span class="line">            mergechunk.<span class="built_in">insert</span>(mergechunk.<span class="built_in">end</span>(),  chunk.mbytes.<span class="built_in">begin</span>(), chunk.mbytes.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入现在处理的最后这个包</span></span><br><span class="line">        mergechunk.<span class="built_in">insert</span>(mergechunk.<span class="built_in">end</span>(),  chunk.mbytes.<span class="built_in">begin</span>(), chunk.mbytes.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 还原包头</span></span><br><span class="line">        <span class="built_in">Serialize</span>(&amp;chunk.mMessageHeader, mergeMessageHeader);</span><br><span class="line">        <span class="built_in">Serialize</span>(&amp;chunk.mMessageHeader, mergeMessageHeader);</span><br><span class="line">        mergeMessageHeader.<span class="built_in">insert</span>(mergeMessageHeader.<span class="built_in">end</span>(), mergeChunk.<span class="built_in">begin</span>(), mergeChunk.<span class="built_in">end</span>());</span><br><span class="line">        mergerChunk = std::<span class="built_in">move</span>(mergeMessageHeader);</span><br><span class="line">        <span class="comment">// 清空这个包对应的分包</span></span><br><span class="line">        decryptedChunks[clientFd].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">uint8_t</span>&gt;&gt; buffs;</span><br><span class="line">    <span class="keyword">if</span> (buffer[<span class="number">0</span>] != <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 不是MSG，直接传入原始数据</span></span><br><span class="line">        buffs = std::<span class="built_in">move</span>(TCPServerImpl::<span class="built_in">ProcessRequest</span>(buffer, messageLength, clientFd));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffs = std::<span class="built_in">move</span>(TCPServerImpl::<span class="built_in">ProcessRequest</span>(mergeChunk.<span class="built_in">data</span>(), mergeChunk.<span class="built_in">size</span>(), clientFd));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送回复</span></span><br><span class="line">    <span class="keyword">if</span> (!buffs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">uint8_t</span>&gt; buff : buffs) &#123;</span><br><span class="line">            <span class="keyword">auto</span> writeBytes = <span class="built_in">send</span>(clientFd, buff.<span class="built_in">data</span>(), buff.<span class="built_in">size</span>(), MSG_ZEROCOPY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">endProcessBuffer</span><span class="params">(<span class="type">int</span> clientFd, <span class="type">int</span> &amp;bytes, <span class="type">char</span> *buffer, <span class="type">int</span> processedBytes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//后面没数据</span></span><br><span class="line">    <span class="keyword">if</span> (processedBytes &gt;= bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还有数据</span></span><br><span class="line">    bytes -= processedBytes;</span><br><span class="line">    <span class="built_in">memmove</span>(buffer, buffer + processedBytes, bytes);</span><br><span class="line">    <span class="built_in">processBuffer</span>(clientFd, bytes, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/" data-id="cm3e9rhx8000070vc3jr23fkj" data-title="OPCUA open62541-包接收流程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/11/09/Mybatis/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Mybatis
        
      </div>
    </a>
  
  
    <a href="/2024/11/05/OPCUA-open62541%E8%AE%A2%E9%98%85%E5%8E%9F%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">OCPUA open62541-订阅监视</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LCR119/">LCR119</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/">LeetCode101</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E5%9B%9E%E6%BA%AF/">回溯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">深度优先搜索</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Makefile/">Makefile</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/REDIS/">REDIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/">Dubbo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Kafka/">Kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/MIT-6824/">MIT-6824</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RabbitMQ/">RabbitMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RocketMQ/">RocketMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/TypeScript/">TypeScript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/">baosight</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/OPC-UA/">OPC_UA</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA/">开源社区</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/">网络系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/">日常开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/ImageMatchingfromHandcraftedtoDeepFeatures-ASurvey/">ImageMatchingfromHandcraftedtoDeepFeatures:ASurvey</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/">分治</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">常用算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">软件设计</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/%E6%8F%8F%E8%BF%B0%E4%B8%8E%E9%9D%A2%E8%AF%95/">描述与面试</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/18/MySql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">MySql-分库分表</a>
          </li>
        
          <li>
            <a href="/2024/12/17/TCP-IP/">TCP/IP</a>
          </li>
        
          <li>
            <a href="/2024/12/17/SpringBoot-Web%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/">SpringBoot-Web容器与自动装配</a>
          </li>
        
          <li>
            <a href="/2024/12/17/SpringBoot-%E5%88%9D%E8%A7%88/">SpringBoot-初览</a>
          </li>
        
          <li>
            <a href="/2024/12/16/%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E6%AF%94%E8%B5%9B/">timeLine</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>