<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-JAVA基础特性" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/26/JAVA%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" class="article-date">
  <time class="dt-published" datetime="2024-10-26T10:16:50.000Z" itemprop="datePublished">2024-10-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/26/JAVA%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/">JAVA基础特性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>当对象被序列化时，被该对象持有的实例变量也会被序列化，所有被引用的对象也会被实例化，这些操作都是自动进行的</p>
<ul>
<li>要让类能被序列化，要实现Serializable接口</li>
<li>如果要让实例变量不被序列化，<strong>用transient关键字修饰</strong></li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>+ </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/26/JAVA%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" data-id="cm3x62vdw0000yovc66mb9c2c" data-title="JAVA基础特性" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux常用命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2024-10-24T09:22:47.000Z" itemprop="datePublished">2024-10-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Linux常用命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><ul>
<li>-A ：所有的进程均显示出来，与 -e 具有同样的效用；</li>
<li>-a ： 显示现行终端机下的所有进程，包括其他用户的进程；</li>
<li>-u ：以用户为主的进程状态 ；</li>
<li>-x ：通常与 a 这个参数一起使用，可列出较完整信息。</li>
<li>-l ：较长、较详细的将该PID 的的信息列出；</li>
<li>-j ：工作的格式 (jobs format)</li>
<li>-f ：做一个更为完整的输出</li>
<li><img src="/2024/10/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/ps.png"></li>
<li>通过<code>ps aux | grep name</code>查询特定名字进程的相关信息</li>
</ul>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><ul>
<li>top的使用方式 top [-d number] | top [-bnp]<ul>
<li>-d number	number代表秒数，表示top命令显示的页面更新一次的间隔 (default&#x3D;5s)</li>
<li>-b	以批次的方式执行top</li>
<li>-n	与-b配合使用，表示需要进行几次top命令的输出结果</li>
<li>-p	指定特定的pid进程号进行观察</li>
</ul>
</li>
<li><img src="/2024/10/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/top.png"></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="cm2t8fzf80002dgvc53cqcmi5" data-title="Linux常用命令" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-开发技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/23/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2024-10-23T02:58:46.000Z" itemprop="datePublished">2024-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/">日常开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/23/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/">开发技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="快速格式化代码"><a href="#快速格式化代码" class="headerlink" title="快速格式化代码"></a>快速格式化代码</h2><ul>
<li>Windows &#x2F; Linux: Shift + Alt + F</li>
<li>macOS: Shift + Option + F</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>在函数上方输入 &#x2F;**，然后按下 Enter，VS Code 会自动生成基本的注释结构。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/23/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" data-id="cm2t8fzfd0006dgvchm5h1q02" data-title="开发技巧" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OPCUA-open62541加密原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/23/OPCUA-open62541%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2024-10-23T02:48:45.000Z" itemprop="datePublished">2024-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>►<a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/">baosight</a>►<a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/OPC-UA/">OPC_UA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/23/OPCUA-open62541%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/">OPUCA open62541-加密原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h2><p><a target="_blank" rel="noopener" href="https://reference.opcfoundation.org/Core/Part6/v104/docs/6.7.2">https://reference.opcfoundation.org/Core/Part6/v104/docs/6.7.2</a><br><img src="/2024/10/23/OPCUA-open62541%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/opcua%E5%8A%A0%E5%AF%86.png" alt="alt text"></p>
<h2 id="加密通信相关代码"><a href="#加密通信相关代码" class="headerlink" title="加密通信相关代码"></a>加密通信相关代码</h2><h3 id="securityPolicy"><a href="#securityPolicy" class="headerlink" title="securityPolicy"></a>securityPolicy</h3><p>+ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UA_SecurityPolicy</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Additional data */</span></span><br><span class="line">    <span class="type">void</span> *policyContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The policy uri that identifies the implemented algorithms */</span></span><br><span class="line">    UA_String policyUri;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Value indicating the crypto strength of the policy, with zero for deprecated or none */</span></span><br><span class="line">    UA_Byte securityLevel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The local certificate is specific for each SecurityPolicy since it</span></span><br><span class="line"><span class="comment">     * depends on the used key length. */</span></span><br><span class="line">    UA_ByteString localCertificate;</span><br><span class="line"></span><br><span class="line">    UA_NodeId certificateGroupId;</span><br><span class="line">    UA_NodeId certificateTypeId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function pointers grouped into modules */</span></span><br><span class="line">    UA_SecurityPolicyAsymmetricModule asymmetricModule; <span class="comment">// 包括证书指纹生成算法，加密算法，签名算法等等</span></span><br><span class="line">    UA_SecurityPolicySymmetricModule symmetricModule;</span><br><span class="line">    UA_SecurityPolicySignatureAlgorithm certificateSigningAlgorithm;</span><br><span class="line">    UA_SecurityPolicyChannelModule channelModule;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> UA_Logger *logger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Updates the ApplicationInstanceCertificate and the corresponding private</span></span><br><span class="line"><span class="comment">     * key at runtime. */</span></span><br><span class="line">    UA_StatusCode (*updateCertificateAndPrivateKey)(UA_SecurityPolicy *policy,</span><br><span class="line">                                                    <span class="type">const</span> UA_ByteString newCertificate,</span><br><span class="line">                                                    <span class="type">const</span> UA_ByteString newPrivateKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Creates a PKCS #10 DER encoded certificate request signed with the server&#x27;s</span></span><br><span class="line"><span class="comment">     * private key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param securityPolicy The securityPolicy to work on.</span></span><br><span class="line"><span class="comment">     * @param subjectName The subject name to use in the Certificate Request.</span></span><br><span class="line"><span class="comment">     *                    If not specified the SubjectName from the current Certificate is used.</span></span><br><span class="line"><span class="comment">     * @param nonce Additional entropy that the caller can provide.</span></span><br><span class="line"><span class="comment">     *              It shall be at least 32 bytes long.</span></span><br><span class="line"><span class="comment">     * @param params A KeyVaue list that can be used for additional parameters later.</span></span><br><span class="line"><span class="comment">     * @param csr Returns the created CSR. If the passed byte string is not empty, nothing is created.</span></span><br><span class="line"><span class="comment">     * @param newPrivateKey Returns the private key if a new one needs to be generated.</span></span><br><span class="line"><span class="comment">     *                      Alternatively, an existing key can be provided,</span></span><br><span class="line"><span class="comment">     *                      which will be used as the CSR key in the security policy.</span></span><br><span class="line"><span class="comment">     *                      This is necessary if the CSR was created under a different security policy</span></span><br><span class="line"><span class="comment">     *                      and the current one only requires an update.</span></span><br><span class="line"><span class="comment">     * @return If the CSR creation was successful, UA_STATUSCODE_GOOD is returned. */</span></span><br><span class="line">    UA_StatusCode (*createSigningRequest)(UA_SecurityPolicy *securityPolicy,</span><br><span class="line">                                          <span class="type">const</span> UA_String *subjectName,</span><br><span class="line">                                          <span class="type">const</span> UA_ByteString *nonce,</span><br><span class="line">                                          <span class="type">const</span> UA_KeyValueMap *params,</span><br><span class="line">                                          UA_ByteString *csr,</span><br><span class="line">                                          UA_ByteString *newPrivateKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Deletes the dynamic content of the policy */</span></span><br><span class="line">    <span class="type">void</span> (*clear)(UA_SecurityPolicy *policy);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="安全令牌轮换"><a href="#安全令牌轮换" class="headerlink" title="安全令牌轮换"></a>安全令牌轮换</h3><p>续订安全令牌的目的是在安全通信通道（如加密会话）中定期更换令牌，以增强安全性并防止重放攻击。</p>
<p>+ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Rules for revolving the token with a renew OPN request: The client is</span></span><br><span class="line"><span class="comment"> * allowed to accept messages with the old token until the OPN response has</span></span><br><span class="line"><span class="comment"> * arrived. The server accepts the old token until one message secured with</span></span><br><span class="line"><span class="comment"> * the new token has arrived.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We recognize whether nextSecurityToken contains a valid next token if the</span></span><br><span class="line"><span class="comment"> * ChannelId is not 0. */</span></span><br><span class="line">UA_ChannelSecurityToken securityToken;    <span class="comment">/* Also contains the channelId */</span></span><br><span class="line">UA_ChannelSecurityToken altSecurityToken; <span class="comment">/* Alternative token for the rollover.</span></span><br><span class="line"><span class="comment">                                           * See the renewState. */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>令牌轮换的规则<ol>
<li>客户端规则: 当客户端发送带有续订的 OpenSecureChannelRequest (OPN) 请求时，客户端可以继续使用旧的安全令牌，直到服务器返回的 OPN 响应到达为止。这意味着客户端在这个过程中还可以接受用旧令牌加密的消息。</li>
<li>服务器规则: 服务器则允许使用旧的安全令牌，直到它收到客户端用新的安全令牌加密的消息为止。即，服务器知道客户端已经开始使用新令牌。</li>
</ol>
</li>
<li>如何识别下一个安全令牌是否有效<br>下一个安全令牌的有效性可以通过检查 nextSecurityToken 中的 ChannelId 字段来确认。如果 ChannelId 不为 0，表示下一个安全令牌有效。ChannelId 是标识通信信道的唯一标识符，通常它在有效的通信会话中是非零的。</li>
<li>renewState是一个状态机，用于跟踪续订请求的状态，以确保安全令牌的顺利轮换。</li>
</ul>
<h3 id="padding（-c文件内搜索add-padding）"><a href="#padding（-c文件内搜索add-padding）" class="headerlink" title="padding（.c文件内搜索add padding）"></a>padding（.c文件内搜索add padding）</h3><p>+<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Assumes that pos can be advanced to the end of the current block */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">padChunk</span><span class="params">(UA_SecureChannel *channel, <span class="type">const</span> UA_SecurityPolicyCryptoModule *cm,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> UA_Byte *start, UA_Byte **pos)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> bytesToWrite = (<span class="type">uintptr_t</span>)*pos - (<span class="type">uintptr_t</span>)start;</span><br><span class="line">    <span class="type">size_t</span> signatureSize = cm-&gt;signatureAlgorithm.</span><br><span class="line">        getLocalSignatureSize(channel-&gt;channelContext);</span><br><span class="line">    <span class="type">size_t</span> plainTextBlockSize = cm-&gt;encryptionAlgorithm.</span><br><span class="line">        getRemotePlainTextBlockSize(channel-&gt;channelContext);</span><br><span class="line">    UA_Boolean extraPadding = (cm-&gt;encryptionAlgorithm.</span><br><span class="line">        getRemoteKeyLength(channel-&gt;channelContext) &gt; <span class="number">2048</span>);</span><br><span class="line">    <span class="type">size_t</span> paddingBytes = (UA_LIKELY(!extraPadding)) ? <span class="number">1u</span> : <span class="number">2u</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> lastBlock = ((bytesToWrite + signatureSize + paddingBytes) % plainTextBlockSize);</span><br><span class="line">    <span class="type">size_t</span> paddingLength = (lastBlock != <span class="number">0</span>) ? plainTextBlockSize - lastBlock : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    UA_LOG_TRACE_CHANNEL(channel-&gt;securityPolicy-&gt;logger, channel,</span><br><span class="line">                        <span class="string">&quot;Add %lu bytes of padding plus %lu padding size bytes&quot;</span>,</span><br><span class="line">                        (<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)paddingLength,</span><br><span class="line">                        (<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)paddingBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the padding. This is &lt;= because the paddingSize byte also has to be</span></span><br><span class="line"><span class="comment">    * written */</span></span><br><span class="line">    UA_Byte paddingByte = (UA_Byte)paddingLength;</span><br><span class="line">    <span class="keyword">for</span>(UA_UInt16 i = <span class="number">0</span>; i &lt;= paddingLength; ++i) &#123;</span><br><span class="line">        **pos = paddingByte;</span><br><span class="line">        ++*pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the extra padding byte if required */</span></span><br><span class="line">    <span class="keyword">if</span>(extraPadding) &#123;</span><br><span class="line">        **pos = (UA_Byte)(paddingLength &gt;&gt; <span class="number">8u</span>);</span><br><span class="line">        ++*pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    + UA_SecureChannel是安全通道的上下文类，包括channel状态，连接配置，安全模式等channel的信息，以及绑定到这个channel上的session，接收到的message chunk等信息</p>
<ul>
<li>计算填充量的公式取决于需要发送的数据量（称为 BytesToWrite）。发送方应首先使用以下公式计算 MessageChunk 中可用的最大空间量（称为 MaxBodySize）：<br><code>MaxBodySize = PlainTextBlockSize * Floor ((MessageChunkSize – HeaderSize  - 1)/CipherTextBlockSize) – SequenceHeaderSize – 签名大小；</code><br>HeaderSize包括MessageHeader和SecurityHeader。 SequenceHeaderSize 始终为 8 字节。<br>在加密期间，处理大小等于 PlainTextBlockSize 的块以生成大小等于 CipherTextBlockSize 的块。这些值取决于加密算法并且可能相同。<ul>
<li>如果 BytesToWrite 小于或等于 MaxBodySize，则 OPC UA 消息可以放入单个块中。在这种情况下，PaddingSize 使用以下公式计算：<code>PaddingSize = PlainTextBlockSize – ((待写字节数 + 签名大小 + 1) % PlainTextBlockSize);</code></li>
<li>如果 BytesToWrite 大于 MaxBodySize，则发送方应写入 PaddingSize 为 0 的 MaxBodySize 字节。剩余的 BytesToWrite – MaxBodySize 字节应在后续 MessageChunk 中发送。</li>
<li>如果 MessageChunk 未加密，则 PaddingSize 和 Padding 字段不会出现。</li>
<li>如果 MessageChunk 未签名，则 Signature 字段不存在</li>
</ul>
</li>
</ul>
<h3 id="sign-encrypt"><a href="#sign-encrypt" class="headerlink" title="sign &amp; encrypt"></a>sign &amp; encrypt</h3><h4 id="asym"><a href="#asym" class="headerlink" title="asym"></a>asym</h4><ul>
<li>更详细的签名算法可以搜UA_Openssl_RSA_Private_Sign  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">UA_StatusCode</span><br><span class="line"><span class="title function_">signAndEncryptAsym</span><span class="params">(UA_SecureChannel *channel, <span class="type">size_t</span> preSignLength,</span></span><br><span class="line"><span class="params">                UA_ByteString *buf, <span class="type">size_t</span> securityHeaderLength,</span></span><br><span class="line"><span class="params">                <span class="type">size_t</span> totalLength)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(channel-&gt;securityMode != UA_MESSAGESECURITYMODE_SIGN &amp;&amp;</span><br><span class="line">    channel-&gt;securityMode != UA_MESSAGESECURITYMODE_SIGNANDENCRYPT)</span><br><span class="line">        <span class="keyword">return</span> UA_STATUSCODE_GOOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sign message */</span></span><br><span class="line">    <span class="type">const</span> UA_SecurityPolicy *sp = channel-&gt;securityPolicy;</span><br><span class="line">    <span class="type">const</span> UA_ByteString dataToSign = &#123;preSignLength, buf-&gt;data&#125;;</span><br><span class="line">    <span class="type">size_t</span> sigsize = sp-&gt;asymmetricModule.cryptoModule.signatureAlgorithm.</span><br><span class="line">        getLocalSignatureSize(channel-&gt;channelContext);</span><br><span class="line">    UA_ByteString signature = &#123;sigsize, buf-&gt;data + preSignLength&#125;;</span><br><span class="line">    UA_StatusCode retval = sp-&gt;asymmetricModule.cryptoModule.signatureAlgorithm.</span><br><span class="line">        sign(channel-&gt;channelContext, &amp;dataToSign, &amp;signature);</span><br><span class="line">    UA_CHECK_STATUS(retval, <span class="keyword">return</span> retval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Specification part 6, 6.7.4: The OpenSecureChannel Messages are</span></span><br><span class="line"><span class="comment">    * signed and encrypted if the SecurityMode is not None (even if the</span></span><br><span class="line"><span class="comment">    * SecurityMode is SignOnly). */</span></span><br><span class="line">    <span class="type">size_t</span> unencrypted_length =</span><br><span class="line">        UA_SECURECHANNEL_CHANNELHEADER_LENGTH + securityHeaderLength;</span><br><span class="line">    UA_ByteString dataToEncrypt = &#123;totalLength - unencrypted_length,</span><br><span class="line">                                &amp;buf-&gt;data[unencrypted_length]&#125;;</span><br><span class="line">    <span class="keyword">return</span> sp-&gt;asymmetricModule.cryptoModule.encryptionAlgorithm.</span><br><span class="line">        encrypt(channel-&gt;channelContext, &amp;dataToEncrypt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="加密的实现"><a href="#加密的实现" class="headerlink" title="加密的实现"></a>加密的实现</h2><p><img src="/2024/10/23/OPCUA-open62541%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/Securechunk.png" alt="alt text"></p>
<h3 id="相关函数定义"><a href="#相关函数定义" class="headerlink" title="相关函数定义"></a>相关函数定义</h3><ul>
<li><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">公钥指纹（Public Key Fingerprint）是一个用于验证公钥真实性的简短标识符。它是通过对公钥应用特定的哈希函数生成的一段唯一的固定长度字符串（通常是十六进制或Base64编码的形式）。公钥指纹的主要作用是提供一种简便的方式来确认或比较公钥，而无需处理完整的公钥内容。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们使用的证书是X509 v3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 用于确认比对公钥指纹</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">VerifyThumprint</span><span class="params">(<span class="type">const</span> std::string &amp;thumprint, <span class="type">const</span> std::string &amp;sendercert)</span></span>;</span><br><span class="line"><span class="comment">// 用于生成公钥指纹</span></span><br><span class="line"><span class="function">std::string <span class="title">GeneratorThumprint</span><span class="params">(<span class="type">const</span> std::string &amp;sendercert)</span></span>;</span><br><span class="line"><span class="comment">// 用于消息的解码</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DecryptBuffer</span><span class="params">(std::vector&lt;uint_8&gt; &amp;input, <span class="type">const</span> std::string &amp;privateKey)</span></span>;</span><br><span class="line"><span class="comment">// 用于验证消息的签名，用公钥再重新生成一个签名，和消息尾部的签名比对</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">VerifySign</span><span class="params">(<span class="type">const</span> std::string &amp;publicKey, std::vector&lt;<span class="type">uint8_t</span>&gt; &amp;content, std::vector&lt;<span class="type">uint8_t</span>&gt; &amp;sig)</span></span>;</span><br><span class="line"><span class="comment">// 用于生成签名</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GeneratorRSASig</span><span class="params">(<span class="type">const</span> std::string &amp;localPrivateKey, std::vector&lt;uint_8&gt; &amp;input, std::vector&lt;uint_8&gt; &amp;sig)</span></span>;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们应该考虑一个更多的情况，如果有更多的加密方式怎么办？</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DecryptBuffer</span><span class="params">(std::vector&lt;<span class="type">uint8_t</span>&gt; &amp;input, <span class="type">const</span> std::string &amp;privateKey)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(privateKey.<span class="built_in">data</span>());</span><br><span class="line">    EVP_PKEY *privateKey = <span class="built_in">d2i_PrivateKey</span>(EVP_PKEY_RSA, <span class="literal">NULL</span>, &amp;p, <span class="built_in">privateKey</span>().<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> RSA_DECRYPT_LENGTH = <span class="number">2048</span>;</span><br><span class="line">    <span class="type">size_t</span> keySize = <span class="built_in">RSA_size</span>(<span class="built_in">EVP_PKEY_get1_RSA</span>(privatekey));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buff[RSA_DECRYPT_LENGTH] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    EVP_PKEY_CTX *ctx = <span class="built_in">EVP_PKEY_CTX_new</span>(privateKey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">EVP_PKEY_decrypt_init</span>(ctx) &lt; <span class="number">0</span> || <span class="built_in">EVP_PKEY_CTX_set_rsa_padding</span>(ctx, RSA_PKCS1_OEAP_PADDING) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; __LINE__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cipherOffset = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">while</span>(cipherOffset &lt; input.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// 每次只能解密固定的长度，RSA_DECRYPT_LENGTH</span></span><br><span class="line">        <span class="type">size_t</span> decryptedBytes = RSA_DECRYPT_LENGTH;</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">EVP_PKEY_decrypt</span>(ctx, buff, &amp;decrypedBytes, input.<span class="built_in">data</span>() + cipherOffset, keySize);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; decryptedBytes; i++) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>((<span class="type">uint8_t</span>)buff[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cipherOffset += keySize;</span><br><span class="line">    &#125;</span><br><span class="line">    input = std::<span class="built_in">move</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">VerifySign</span><span class="params">(<span class="type">const</span> std::string &amp;publicKey, std::vector&lt;<span class="type">uint8_t</span>&gt; &amp;content, std::vector&lt;<span class="type">uint8_t</span>&gt; &amp;sig)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(publicKey.<span class="built_in">data</span>());</span><br><span class="line">    <span class="keyword">auto</span> cert = <span class="built_in">d2i_X509</span>(<span class="literal">nullptr</span>, &amp;p, publicKey.<span class="built_in">size</span>());</span><br><span class="line">    EVP_PKEY *realPublicKey = <span class="built_in">X509_get_pubkey</span>(cert);</span><br><span class="line">    <span class="type">int</span> sigNid = <span class="built_in">X509_get_signature_nid</span>(cert);</span><br><span class="line">    <span class="type">int</span> sigLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(sigNid) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">668</span>:</span><br><span class="line">            sigLength = <span class="number">256</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    EVP_MD_CTX *ctx = <span class="built_in">EVP_MD_CTX_create</span>();</span><br><span class="line">    <span class="keyword">if</span>(!ctx) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    EVP_PKEY_CTX *evpKeyCtx;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">EVP_DisgestVerifyInit</span>(ctx, &amp;evpKeyCtx, <span class="built_in">EVP_sha256</span>(), <span class="literal">NULL</span>, realPublicKey) != <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EVP_PKEY_CTX_set_rsa_padding</span>(evpKeyCtx, RSA_PKCS1_PADDING);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">EVP_DisgestVerifyUpdate</span>(ctx, content.<span class="built_in">data</span>(), content.<span class="built_in">size</span>()) != <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">EVP_DisgestVerifyFinal</span>(ctx, sig.<span class="built_in">data</span>(), sig.<span class="built_in">size</span>()) != <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EVP_MD_CTX_free</span>(ctx);</span><br><span class="line">    <span class="built_in">EVP_PKEY_free</span>(realPublicKey);</span><br><span class="line">    <span class="built_in">X509_free</span>(cert);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GeneratorRSASig</span><span class="params">(<span class="type">const</span> std::string &amp;localPrivateKey, std::vector&lt;uint_8&gt; &amp;input, std::vector&lt;uint_8&gt; &amp;sig)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> signLength = sig.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(localPrivateKey.<span class="built_in">data</span>());</span><br><span class="line">    EVP_PKEY *privateKey = <span class="built_in">d2i_PrivateKey</span>(EVP_PKEY_RSA, <span class="literal">NULL</span>, &amp;p, localPrivateKey.<span class="built_in">size</span>());</span><br><span class="line">    EVP_MD_CTX *mdctx = <span class="literal">NULL</span>;</span><br><span class="line">    EVP_PKEY_CTX *evpkeyCtx = <span class="literal">NULL</span>;</span><br><span class="line">    mdctx = <span class="built_in">EVP_MD_CTX_create</span>();</span><br><span class="line">    <span class="built_in">EVP_DigestSignInit</span>(mdctx, &amp;evpkeyCtx, <span class="built_in">EVP_sha256</span>(), <span class="literal">NULL</span>, privateKey);</span><br><span class="line">    <span class="built_in">EVP_PKEY_CTX_set_rsa_padding</span>(evpkeyCtx, RSA_PKCS1_PADDING);</span><br><span class="line">    <span class="built_in">EVP_DigestSignUpdate</span>(mdtcx, input.<span class="built_in">data</span>(), input.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">EVP_DigestSignFinal</span>(mdtcx, sig.<span class="built_in">data</span>(), &amp;siglength);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li>流程：<ul>
<li>openSecureChannelAck<ol>
<li>如果channel是sign或者sign&amp;encrypt，加载证书</li>
<li>解密消息，验证公钥签名</li>
<li>根据channel类型选择是否加密、生成指纹。先知道待加密的报文和签名的长度，签名长度是固定的，以此确认是不是要添加padding(padding流程见前，注意这个padding不是加密、签名的padding，是一个协议的填充)，然后生成签名，加密回复消息</li>
</ol>
</li>
</ul>
</li>
<li>QA：<ul>
<li>生成公钥指纹应该用什么算法？是协商决定，还是默认使用某个算法？最后使用的方法合理吗？<br>我们使用的证书是X509 v3，使用的生成指纹算法是SHA-256，具有较好的安全性</li>
<li>有更多的加密算法怎么办？使用什么设计模式？怎么指定更多的加密算法？<br>指定的方法是在header的一个字段指定</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/23/OPCUA-open62541%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/" data-id="cm2la0nwc000534vcbazx92x8" data-title="OPUCA open62541-加密原理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MVC&amp;DDD" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/22/MVC&DDD/" class="article-date">
  <time class="dt-published" datetime="2024-10-22T07:48:38.000Z" itemprop="datePublished">2024-10-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>►<a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/22/MVC&DDD/">MVC &amp; DDD</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="传统的MVC结构："><a href="#传统的MVC结构：" class="headerlink" title="传统的MVC结构："></a>传统的MVC结构：</h2><ul>
<li><p>分层</p>
<ol>
<li>M - model 对象层，封装到 domain 里。</li>
<li>V - view 展示层，但因为目前都是前后端分离的项目，几乎不会在后端项目里写 JSP 文件了。</li>
<li>C - Controller 控制层，对外提供接口实现类。HTTP接口</li>
<li>DAO 算是单独拿出来用户处理数据库操作的层。</li>
<li>Service：功能方法，服务层逻辑的实现</li>
</ol>
</li>
<li><p>调用流程：<br><img src="/2024/10/22/MVC&DDD/MVC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></p>
</li>
</ul>
<h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><ul>
<li>什么是DDD：DDD 是一种软件设计方法。也就是说 DDD 是指导我们做软件工程设计的一种手段，它提供了用切割工程模型的各类技巧<ul>
<li>充血模型：指将对象的属性信息与行为逻辑聚合到一个类中，常用的手段如在对象内提供属于当前对象的信息校验、拼装缓存Key、不含服务接口调用的逻辑处理等。</li>
<li><img src="/2024/10/22/MVC&DDD/%E5%85%85%E8%A1%80&%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B.png"></li>
<li>DDD最大的区别在于把原有的众多 Service + 数据模型的方式，拆分为独立的有边界的领域模块。每个领域内创建自身所属的；领域对象（实体、聚合、值对象）、仓储服务(DAO 操作)、工厂、端口适配器Port（调用外部接口的手段）等。   </li>
<li>在原本的 Service + 贫血的数据模型开发指导下，Service 串联调用每一个功能模块。这些基础设施（对象、方法、接口）是被相互掉调用的。这也是因为贫血模型并没有面向对象的设计，所有的需求开发只有详细设计。  </li>
<li>换到充血模型下，现在我们以一个领域功能为聚合，拆分一个领域内所需的 Service 为领域服务，VO、Req、Res 重新设计为领域对象，DAO、Redis 等持久化操作为仓储等。举例；一套账户服务中的，授信认证、开户、提额降额等，每一个都是一个独立的领域，在每个独立的领域内，创建自身领域所需的各项信息。</li>
<li>领域模型还有一个特点，它自身只关注业务功能实现，不与外部任何接口和服务直连。如；不会直接调用 DAO 操作库，也不会调用缓存操作 Redis，更不会直接引入 RPC 连接其他微服务。而是通过仓库和端口适配器，定义调用外部数据的含有出入参对象的接口标准，让基础设施层做具体的调用实现。通过这样的方式让领域只关心业务实现，同时做好防腐。</li>
<li>仓储与适配器：在 DDD 的设计方法中，领域层做到了只关心领域服务实现。最能体现这样设计的就是仓库和适配器的设计。通常在 Service + 数据模型的设计中，会在 Service 中引入 Redis、RPC、配置中心等各类其他外部服务。但在 DDD 中，通过仓储和适配器以及基础设施层的定义，解耦了这部分内容。</li>
</ul>
</li>
<li>DDD VS MVC<ul>
<li>如果你接触过较大型且已经长期维护项目的 MVC 架构，你就会发现这里的 DAO、PO、VO 对象，在 Service 层相互调用。那么长期开发后，就导致了各个 PO 里的属性字段数量都被撑的特别大。这样的开发方式，将”状态”、“行为“分离到不同的对象中，代码的意图渐渐模糊，膨胀、臃肿和不稳定的架构，让迭代成本增加。</li>
<li>而 DDD 架构首先以解决此类问题为主，将各个属于自己领域范围内的行为和逻辑封装到自己的领域包下处理。这也是 DDD 架构设计的精髓之一。它希望在分治层面合理切割问题空间为更小规模的若干子问题，而问题越小就容易被理解和处理，做到高内聚低耦合。这也是康威定律所提到的，解决复杂场景的设计主要分为：分治、抽象和知识。</li>
<li><img src="/2024/10/22/MVC&DDD/MVC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></li>
<li><img src="/2024/10/22/MVC&DDD/MVC%E8%BF%81%E7%A7%BBDDD.png"></li>
</ul>
</li>
<li>DDD模块示例：<ul>
<li><img src="/2024/10/22/MVC&DDD/DDD%E6%A8%A1%E5%9D%97.png"></li>
<li><img src="/2024/10/22/MVC&DDD/DDD%E6%A8%A1%E5%9D%972.png"></li>
<li>DDD分层解析：<ol>
<li>领域层：一个领域层内可以有多个领域包，例如账户领域包，结算领域包。每一个 domain 下的领域包内，都包括：model 模型、仓储、接口、事件和服务的处理。</li>
</ol>
<ul>
<li>model 模型对象<ol>
<li>aggreate：聚合对象，实体对象、值对象的协同组织，就是聚合对象。</li>
<li>entity：实体对象，大多数情况下，实体对象(Entity)与数据库持久化对象(PO)是1v1的关系，但也有为了封装一些属性信息，会出现1vn的关系。</li>
<li>valobj：值对象，通过对象属性值来识别的对象 By 《实现领域驱动设计》</li>
</ol>
</li>
<li>repository 仓储服务：从数据库等数据源中获取数据，传递的对象可以是聚合对象、实体对象，返回的结果可以是：实体对象、值对象。因为仓储服务是由基础层(infrastructure) 引用领域层(domain)，是一种依赖倒置的结构，但它可以天然的隔离PO数据库持久化对象被引用。</li>
<li>adapter 接口服务：是依赖于外包的其他 HTTP&#x2F;RPC 接口的封装调用，通过在 domain 领域层定义适配器接口，再由依赖于 domain 的基础层设施层或者一个单独的专门处理接口的额外分层，来实现 domain 定义的适配器接口，完成对依赖的 HTTP&#x2F;RPC 进行封装处理。</li>
<li>event 事件消息：在服务实现中，经常会有业务完成后，对外发送消息的情况。这个时候，可以在领域模型中定义事件消息的接口，再由基础设施层完成消息的推送。</li>
<li>service 服务设计：这里要注意，不要以为定义了聚合对象，就把超越1个对象以外的逻辑，都封装到聚合中，这会让你的代码后期越来越难维护。聚合更应该注重的是和本对象相关的单一简单封装场景，而把一些重核心业务放到 service 里实现。此外，如果你的设计模式应用不佳，那么无论是领域驱动设计、测试驱动设计还是换了三层和四层架构，你的工程质量依然会非常差。</li>
</ul>
<ol start="2">
<li>基础设施层：提供数据库持久化、提供Redis和配置中心数据支撑、提供事件消息推送、提供外部服务接口封装。总之这一层的核心目的就是更好的辅助 domain 领域层完成领域功能的开发。而调用方式则为依赖倒置，也就是领域服务层定义接口，基础设施层做功能实现。这样可以有效的避免基础设施层中的对象被对外暴露，如数据库持久化对象，在这样的分层结构中，天然的被保护在基础设施层中，外部是没法引入的，否则就循环依赖了。</li>
</ol>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/22/MVC&DDD/" data-id="cm31tgkof0000qovc06fxg20c" data-title="MVC &amp; DDD" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IO多路复用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/21/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2024-10-21T08:47:21.000Z" itemprop="datePublished">2024-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/">网络系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/21/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">IO多路复用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2383534">https://cloud.tencent.com/developer/article/2383534</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hollis_chuang/article/details/116310861">https://blog.csdn.net/hollis_chuang/article/details/116310861</a><br><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#i-o-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#i-o-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8</a></p>
<h2 id="简单socket模型"><a href="#简单socket模型" class="headerlink" title="简单socket模型"></a>简单socket模型</h2><ol>
<li>服务端调用socket()函数，指定网络协议和传输层协议，调用bind()绑定IP和端口</li>
<li>调用listen()监听，客户端connect()建立连接，服务端accept()取出与客户端的连接</li>
<li>连接建立后read()，write()读写数据</li>
<li>在这个过程里面，有两个socket，服务端监听端口的socket和客户端与服务端用于连接传输的socket</li>
</ol>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><ul>
<li>复用IO的基本思路就是通过slect或poll、epoll 来监控多fd ，来达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的。当发现某个描述符就绪之后，能够通知程序进行相应的读写操作。</li>
</ul>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul>
<li><code>int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout);</code></li>
<li>运行机制：参数有一个 fd_set 集合，其实这是一个 long 类型的数组，数组元素能够与已经打开的文件句柄（例如 Socket 句柄，又或者其它文件）建立联系。当我们调用 select 函数时，内核会根据 IO 状态对 fd_set 的内容进行修改，从而通知执行 select 函数的进程哪一个文件或者 Socket 是可读的。select 函数与同步阻塞模型并无过多区别，甚至还多出了一部分操作（监视 socket &#x2F;调用 select 函数），导致更低的效率。<br><img src="/2024/10/21/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/select.png" alt="alt text"></li>
<li>API<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO(<span class="type">int</span> fd, fd_set* fds)   <span class="comment">// 清空集合</span></span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set* fds)    <span class="comment">// 将给定的描述符加入集合</span></span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set* fds)  <span class="comment">// 判断指定描述符是否在集合中 </span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set* fds)    <span class="comment">// 将给定的描述符从文件中删除 </span></span><br></pre></td></tr></table></figure></li>
<li>使用实例：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket, client_sockets[MAX_CLIENTS], max_sd, activity, valread;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化客户端套接字数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        client_sockets[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置地址和端口</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 清空描述符集合并添加服务器套接字</span></span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;readfds);</span><br><span class="line">        <span class="built_in">FD_SET</span>(server_fd, &amp;readfds);</span><br><span class="line">        max_sd = server_fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加所有客户端套接字到集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sd = client_sockets[i];</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">FD_SET</span>(sd, &amp;readfds);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; max_sd) &#123;</span><br><span class="line">                max_sd = sd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待活动</span></span><br><span class="line">        activity = <span class="built_in">select</span>(max_sd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> ((activity &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查服务器套接字是否有新连接</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(server_fd, &amp;readfds)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, &amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;New connection: socket fd %d, IP %s, port %d\n&quot;</span>,</span><br><span class="line">                  new_socket, <span class="built_in">inet_ntoa</span>(address.sin_addr), <span class="built_in">ntohs</span>(address.sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加新客户端到数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client_sockets[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    client_sockets[i] = new_socket;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查客户端套接字是否有数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sd = client_sockets[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sd, &amp;readfds)) &#123;</span><br><span class="line">                valread = <span class="built_in">read</span>(sd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">                <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123; <span class="comment">// 客户端断开连接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client disconnected: socket fd %d\n&quot;</span>, sd);</span><br><span class="line">                    <span class="built_in">close</span>(sd);</span><br><span class="line">                    client_sockets[i] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 接收到数据</span></span><br><span class="line">                    buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client %d sent: %s\n&quot;</span>, sd, buffer);</span><br><span class="line">                    <span class="built_in">send</span>(sd, <span class="string">&quot;Message received&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Message received&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>优势：用户可以在一个线程内同时处理多个 socket 的 IO 请求。用户可以注册多个 socket，然后调用 select 函数读取被激活的 socket，从而实现在同一个线程内同时处理多个 IO 请求，在这点上select 函数与同步阻塞模型不同，因为在同步阻塞模型中需要通过多线程才能达到这个目的。话说回来，为啥我们不直接使用多进程&#x2F;多线程技术，而是要使用 IO 多路复用技术呢?这是因为，使用 IO 多路复用技术，系统不必创建和维护进程&#x2F;线程，从而节约了系统的开销。</li>
<li>缺点：<ol>
<li>检查调用情况这件事发生在内核态，也就是调用select函数时，需要把fd_set集合从用户态拷贝到内核态，当fd_set集合很大时，这个开销将会非常巨大，且需要在内核遍历传递进来的所有fd_set，当fd_set集合很大时，这个开销将会非常巨大。</li>
<li>fd_set集合大小有限制</li>
</ol>
</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul>
<li><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code></li>
<li>运行机制：select 函数中，内核对 fd_set 集合的大小做出了限制，大小不可变为1024(要改变需要重新编译内核)；而 poll 函数中，并没有最大文件描述符数量的限制（基于链表存储）。其余和select没有区别</li>
<li>API<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 需要监视的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 需要内核监视的事件</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fds[], <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">// POLLIN 描述符可读。可以从中读取数据（例如，TCP 套接字有数据到来，或标准输入有数据可读）。</span></span><br><span class="line"><span class="comment">// POLLOUT 描述符可写。可以向其中写入数据（例如，TCP 套接字可以发送数据，或者文件可以写入）。</span></span><br><span class="line"><span class="comment">// POLLERR 描述符出现错误。该描述符发生了错误，程序应当尽快处理，通常伴随着读取错误（如套接字连接中断）。</span></span><br><span class="line"><span class="comment">// POLLHUP 描述符挂起。表示描述符已经关闭，或者连接被断开（例如，TCP 套接字被远程主机关闭）。这常用于检测连接的断开。</span></span><br></pre></td></tr></table></figure></li>
<li>使用示例<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务端套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址和端口</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(server_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server listening on port %d\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 `poll` 文件描述符数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[MAX_CLIENTS + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">1</span>; <span class="comment">// 当前监听的文件描述符数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置监听的服务端套接字</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = server_fd;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN; <span class="comment">// 关注读事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化客户端槽位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAX_CLIENTS; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>; <span class="comment">// 表示未使用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Waiting for events...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 poll 等待事件发生</span></span><br><span class="line">        <span class="type">int</span> activity = <span class="built_in">poll</span>(fds, nfds, <span class="number">-1</span>); <span class="comment">// -1 表示无限等待</span></span><br><span class="line">        <span class="keyword">if</span> (activity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Poll error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历文件描述符数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123; <span class="comment">// 有读事件</span></span><br><span class="line">                <span class="keyword">if</span> (fds[i].fd == server_fd) &#123;</span><br><span class="line">                    <span class="comment">// 服务端套接字有新连接</span></span><br><span class="line">                    new_socket = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen);</span><br><span class="line">                    <span class="keyword">if</span> (new_socket &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;Accept failed&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;New connection accepted, fd: %d\n&quot;</span>, new_socket);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 添加新客户端到 `poll` 数组</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= MAX_CLIENTS; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fds[j].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                            fds[j].fd = new_socket;</span><br><span class="line">                            fds[j].events = POLLIN; <span class="comment">// 关注读事件</span></span><br><span class="line">                            <span class="keyword">if</span> (j + <span class="number">1</span> &gt; nfds) &#123;</span><br><span class="line">                                nfds = j + <span class="number">1</span>; <span class="comment">// 更新最大监控数</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 客户端套接字有数据</span></span><br><span class="line">                    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">                    <span class="type">int</span> valread = <span class="built_in">read</span>(fds[i].fd, buffer, BUFFER_SIZE);</span><br><span class="line">                    <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 客户端断开连接</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Client disconnected, fd: %d\n&quot;</span>, fds[i].fd);</span><br><span class="line">                        <span class="built_in">close</span>(fds[i].fd);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>; <span class="comment">// 重置槽位</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 打印客户端消息并回显</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Received from client (fd: %d): %s\n&quot;</span>, fds[i].fd, buffer);</span><br><span class="line">                        <span class="built_in">send</span>(fds[i].fd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fds[i].fd != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">close</span>(fds[i].fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul>
<li><p>源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建epoll实例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 要epoll在哪个文件描述符上干什么。第一个参数是epoll实例的文件描述符，第二个是要监听的目标文件描述符（socket、pipe...），op是操作类型：添加修改删除，event是要监听的事件，包括事件类型和其他属性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>; </span><br><span class="line"><span class="comment">// 监听。234参数分别是已触发的事件(内核负责填写)，最大事件数目，超时时间(-1就是无限等待)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>epoll_create：创建一个 epoll 句柄，其中 size 表示内核要监听的描述符数量</li>
<li>epoll_ctl：注册要监听的事件类型。在每次注册新的事件到 epoll 句柄中时，会把所有的描述符拷贝进内核，而不是在 epoll_wait 的时候重复拷贝。epoll 保证了每个描述符在整个过程中只会拷贝一次。epoll_ctl函数添加进来的事件都会被放在红黑树的某个节点内</li>
<li>epoll_wait：等待事件的就绪，成功时返回就绪的事件数目</li>
</ol>
</li>
<li><p>示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置非阻塞模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_nonblocking</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, epfd, nfds;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev, events[MAX_EVENTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建监听套接字</span></span><br><span class="line">    listen_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字选项和非阻塞模式</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line">    <span class="built_in">set_nonblocking</span>(listen_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listen_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listen_fd, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listen_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 epoll 实例</span></span><br><span class="line">    epfd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listen_fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听套接字添加到 epoll</span></span><br><span class="line">    ev.events = EPOLLIN; <span class="comment">// 监听读事件</span></span><br><span class="line">    ev.data.fd = listen_fd;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listen_fd, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listen_fd);</span><br><span class="line">        <span class="built_in">close</span>(epfd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server is listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待事件触发</span></span><br><span class="line">        nfds = <span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == listen_fd) &#123;</span><br><span class="line">                <span class="comment">// 新的客户端连接</span></span><br><span class="line">                <span class="type">int</span> client_fd = <span class="built_in">accept</span>(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (client_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">set_nonblocking</span>(client_fd);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加新连接到 epoll</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET; <span class="comment">// 边缘触发模式</span></span><br><span class="line">                ev.data.fd = client_fd;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, client_fd, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl: client_fd&quot;</span>);</span><br><span class="line">                    <span class="built_in">close</span>(client_fd);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;New connection: fd=%d\n&quot;</span>, client_fd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理客户端数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> client_fd = events[i].data.fd;</span><br><span class="line">                <span class="type">int</span> bytes_read = <span class="built_in">read</span>(client_fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 客户端关闭连接或出错</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Connection closed: fd=%d\n&quot;</span>, client_fd);</span><br><span class="line">                    <span class="built_in">close</span>(client_fd);</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, client_fd, <span class="literal">NULL</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 回显数据</span></span><br><span class="line">                    buf[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Received from fd=%d: %s\n&quot;</span>, client_fd, buf);</span><br><span class="line">                    <span class="built_in">write</span>(client_fd, buf, bytes_read);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(listen_fd);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>epoll 是 poll 的增强版，在获取事件时，epoll 无需遍历整个被监听的描述符集，而是只需遍历被内核 IO 事件异步唤醒而加入 Ready 队列的描述符集合即可。因此，epoll 能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。epoll 会在 epoll_ctl 时为每个描述符指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的描述符加入一个就绪链表。epoll_wait 实际上就是去就绪链表中查看有没有就绪的描述符。<br><img src="/2024/10/21/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/epoll.png"><br><img src="/2024/10/21/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/epoll2.png"></p>
</li>
<li><p>优势：</p>
<ol>
<li>没有最大连接数限制</li>
<li>不用轮询所有socket连接，只需要处理活跃连接。使用红黑树修改节点是O(N)(每次发现fd变化，修改节点更快)</li>
<li>epoll是通过内核与用户空间mmap同一块内存实现的，mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址。减少用户态和内核态之间的数据交换的复制开销。 – 内核直接修改物理内存，避免像select和poll一样进行用户空间到内核空间的复制</li>
<li>当一个文件描述符注册到 epoll 时，内核会在相关的文件描述符上挂载回调函数。当某个事件发生时（如套接字变得可读），内核会触发回调函数，直接将事件放入待处理的链表中，而无需在事件发生后再主动扫描所有监听的描述符。这种设计避免了内核遍历所有监听文件描述符的开销。</li>
</ol>
</li>
<li><p>模式：</p>
<ul>
<li>水平触发（LT）：默认工作模式，当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；等到下次调用 epoll_wait 时，会再次通知此事件</li>
<li>边缘触发（ET）：当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次通知此事件</li>
<li>ET 模式减少了 epoll 事件的触发次数，其效率比 LT 模式下高。为什么呢？如果我们使用 LT 模式的话，系统中一旦有大量不需要读写的就绪文件描述符，每次调用 epoll_wait 都会返回，大大降低处理程序检索自己关心的就绪文件描述符的效率。如果使用的是 ET 模式，当被监控的文件描述符上有可读写事件发生时，epoll_wait 会通知处理程序去读写，如果这次没有把数据全部读写完，下次调用 epoll_wait 不会通知你，即它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。在这种模式下，系统不会充斥大量你不关心的就绪文件描述符，故其效率较高。</li>
</ul>
</li>
<li><p>总结：select，poll 需要自己不断轮询所有描述符集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。epoll 其实也需要调用 epoll_wait 不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪描述符放入就绪链表中，并唤醒在 epoll_wait 中进入睡眠的进程。虽然都要睡眠和交替，但是 select 和 poll 在醒着的时候要遍历整个描述符集合，而epoll在醒着的时候只要判断一下就绪链表是否为空即可，这就是回调机制带来的性能提升，节省了大量的 CPU 时间。</p>
</li>
</ul>
<h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><ol>
<li>IO 效率：select 只知道有 IO 事件发生，却不知道是哪几个流，只能采取轮询所有流的方式，故其具有 O(n) 的无差别轮询复杂度，处理的流越多，无差别轮询时间就越长；poll 与 select 并无区别，它的时间复杂度也是 O(n)；epoll 会将哪个流发生了怎样的 IO 事件通知我们（当描述符就绪时，系统注册的回调函数会被调用，将就绪描述符放到 readyList 里面），它是事件驱动的，其时间复杂度为 O(1)</li>
<li>操作方式：select 和 poll 都是采取遍历的方式，而 epoll 则是采取了回调的方式</li>
<li>底层实现：select 的底层实现为数组，poll 的底层实现为链表，而 epoll 的底层实现为红黑树</li>
<li>最大连接数：select 的最大连接数为 1024 或 2048，而 poll 和 epoll 是无上限的</li>
<li>对描述符的拷贝：select 和 poll 每次被调用时都会把描述符集合从用户态拷贝到内核态，而 epoll 在调用 epoll_ctl 时会拷贝进内核并保存，之后每次 epoll_wait 时不会拷贝</li>
<li>性能：epoll 在绝大多数情况下性能远超 select 和 poll，但在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，因为 epoll 的通知机制需要很多函数回调</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/21/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" data-id="cm2irwt2n00002svcdb9obfdt" data-title="IO多路复用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IO模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2024-10-21T07:30:43.000Z" itemprop="datePublished">2024-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>►<a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/">网络系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/">IO模型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="IO背景"><a href="#IO背景" class="headerlink" title="IO背景"></a>IO背景</h2><ul>
<li>发送一条消息的流程：<ol>
<li>应用A把消息发送到TCP发送缓存区</li>
<li>TCP缓存区发送消息，传递到B服务器的TCP接收缓存区</li>
<li>应用B从TCP接收缓存区读取数据</li>
</ol>
</li>
</ul>
<h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h2><ul>
<li>IO模型：<ol>
<li>阻塞式IO，同步阻塞</li>
<li>非阻塞式IO，同步非阻塞</li>
<li>多路复用IO，同步非阻塞</li>
<li>信号驱动IO，同步非阻塞</li>
<li>异步IO，异步</li>
</ol>
</li>
</ul>
<h3 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h3><ul>
<li>在应用调用recvfrom读取数据时，其系统调用知道数据包到达切被复制到应用缓冲区中或者发送错误时才返回，在此期间一直会等待，进程从调用到返回这段时间内都是被阻塞的成为阻塞IO；</li>
<li><img src="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/image.png"></li>
</ul>
<h3 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h3><ul>
<li>非阻塞IO是在应用调用recvfrom读取数据时，如果该缓冲区没有数据的话，就会直接返回一个EWOULDBLOCK错误，不会让应用一直等待中。在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要不断的调用recvfrom请求，直到读取到它数据要的数据为止。（轮询，中断）</li>
<li>事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</li>
<li><img src="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/image1.png" alt="alt text"></li>
</ul>
<h3 id="多路复用IO-–-复用的是线程，而不是IO连接，目的是让少量线程可以处理多个IO连接"><a href="#多路复用IO-–-复用的是线程，而不是IO连接，目的是让少量线程可以处理多个IO连接" class="headerlink" title="多路复用IO – 复用的是线程，而不是IO连接，目的是让少量线程可以处理多个IO连接"></a>多路复用IO – 复用的是线程，而不是IO连接，目的是让少量线程可以处理多个IO连接</h3><ul>
<li>背景：如果在并发的环境下，可能会N个人向应用B发送消息，这种情况下我们的应用就必须创建多个线程去读取数据，每个线程都会自己调用recvfrom去读取数据。并发情况下服务器很可能一瞬间会收到几十上百万的请求，这种情况下应用B就需要创建几十上百万的线程去读取数据，同时又因为应用线程是不知道什么时候会有数据读取，为了保证消息能及时读取到，那么这些线程自己必须不断的向内核发送recvfrom请求来读取数据，这种方法会占用大量资源。</li>
<li>进程通过将一个或多个fd传递给select（或者其他IO复用API），阻塞在select操作上，select帮我们侦测多个fd是否准备就绪，当有fd准备就绪时，select返回数据可读状态，应用程序再调用recvfrom读取数据。</li>
<li><strong>多路复用IO主要用于处理多个IO连接时候的场景。在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</strong>也许有朋友会说，我可以采用多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，<strong>而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</strong></li>
<li><img src="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/image2.png" alt="alt text"></li>
</ul>
<h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><ul>
<li>开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数，此时请求即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知映应用线程调用recvfrom来读取数据。</li>
<li><img src="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/image4.png" alt="alt text"></li>
<li>对比多路复用：IO复用模型里面的select虽然可以监控多个fd了，但select其实现的本质上还是通过不断的轮询fd来监控数据状态， 因为大部分轮询请求其实都是无效的，所以信号驱动IO意在通过这种建立信号关联的方式，实现了发出请求后只需要等待数据就绪的通知即可，这样就可以避免大量无效的数据状态轮询操作。</li>
</ul>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><ul>
<li>不管是IO复用还是信号驱动，我们要读取一个数据总是要发起两阶段的请求，第一次发送select请求，询问数据状态是否准备好，第二次发送recevform请求读取数据。（这也就是为什么上面四种都是同步IO）。如果应用发送完指令后就不再参与过程了，只需要等待最终完成结果的通知，那么这就属于异步。</li>
<li>应用告知内核启动某个操作，并让内核在整个操作完成之后，通知应用，这种模型与信号驱动模型的主要区别在于，信号驱动IO只是由内核通知我们合适可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成。</li>
<li><img src="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/image5.png" alt="alt text"></li>
</ul>
<h3 id="两种高性能IO设计模式：Reactor和Proactor"><a href="#两种高性能IO设计模式：Reactor和Proactor" class="headerlink" title="两种高性能IO设计模式：Reactor和Proactor"></a>两种高性能IO设计模式：Reactor和Proactor</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/21/IO%E6%A8%A1%E5%9E%8B/" data-id="cm2irwt2s00012svc6y761ryd" data-title="IO模型" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数字签名" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" class="article-date">
  <time class="dt-published" datetime="2024-10-17T08:21:47.000Z" itemprop="datePublished">2024-10-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/">数字签名</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数字签名的主要的作用是认证签署人身份，说得具体点，就是让所有人能够确认这个数字签名是不是由私钥的持有人创建的。数字签名是由签名算法去生成的，签名算法的输入有两个，一个是私钥，另一个是被签署的信息（一般是消息的一个摘要），输出的一个字符串就是数字签名了。签名到底是不是由私钥持有人签署的，要通过验证算法判断。验证算法有三个输入，一个是信息本身，另外一个是数字签名，第三个是公钥，输出的结果就是验证成功或者验证失败。数字签名过程中，私钥是“签名 key”，公钥是“验证 key”。</p>
<h2 id="流程原理"><a href="#流程原理" class="headerlink" title="流程原理"></a>流程原理</h2><ol>
<li>用hash函数取出要签名信息的摘要(digest)</li>
<li>用发送方的私钥加密这个摘要</li>
<li>接受方收到信息之后，先用公钥解密摘要，再对原文使用hash函数生成摘要</li>
<li>对比解密摘要和新生成的摘要</li>
</ol>
<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><ol>
<li>为什么可以用私钥加密，公钥解密？<br>A：以一个非对称加密算法为例，加密和解密的过程其实是可逆的，关键在于用什么秘钥加密，希望让什么秘钥能解密</li>
<li>有被伪造的风险吗？公钥就可以解密，摘要是完全暴露的<br>A：这就要依靠hash函数，虽然hash值是暴露的，但是基于hash值伪造一个</li>
</ol>
<h2 id="签名：防止篡改-加密：防止泄密"><a href="#签名：防止篡改-加密：防止泄密" class="headerlink" title="签名：防止篡改 &amp; 加密：防止泄密"></a>签名：防止篡改 &amp; 加密：防止泄密</h2><ul>
<li>同时使用加密和签名？当用公钥加密后，还需要对明文做以下操作（这套算法保证明文改动会使得被私钥签名后的结果改动）：<ol>
<li>用哈希算法抽取明文摘要（非对称算法很耗时，对大量数据加密需要很大算力）</li>
<li>对这个明文摘要用私钥签名</li>
</ol>
</li>
<li>验签时，用私钥得到解密后的明文，用公钥得到解签后的摘要，从明文中抽取摘要对比即可</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" data-id="cm2ibtc860000c0vc6ry07lpk" data-title="数字签名" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-非对称加密算法原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/17/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2024-10-17T06:59:54.000Z" itemprop="datePublished">2024-10-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/17/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/">非对称加密算法原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/48249182">https://zhuanlan.zhihu.com/p/48249182</a></li>
<li><a target="_blank" rel="noopener" href="https://ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">https://ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></li>
</ol>
<ul>
<li>欧拉定理<br><img src="/2024/10/17/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/%7B297162E5-5F03-4740-A429-7DB33A5DDC51%7D.png"></li>
<li>欧拉函数<br>f(n)是指1-n范围内和n互质的整数的个数</li>
<li>模反函数<br>如果两个正整数a和n互质，那么一定可以找到整数b，使得ab-1被n整除，或者说ab被n除的余数是1。<br>b是a的模反函数</li>
<li>秘钥生成过程</li>
</ul>
<ol>
<li>选择两个不相等质数p，q</li>
<li>计算p * q &#x3D; n，n的长度是秘钥长度，一般1024位即可</li>
<li>计算n的欧拉函数f(n)</li>
<li>随机选一个整数e，满足1 &lt; e &lt; f(n)，且e和f(n)互质，这个值一般就是65537</li>
<li>计算e关于f(n)的模反函数d</li>
<li>ne封装为公钥，nd封装为私钥</li>
</ol>
<ul>
<li>加密&amp;解密</li>
<li>加密就是计算 m^e ≡ c (mod n) (m &lt; n)</li>
<li>解密就是计算 c^d ≡ m (mod n)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/17/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" data-id="cm2d10me300005cvccp61f7oz" data-title="非对称加密算法原理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OPCUA握手的简单实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/17/OPCUA%E6%8F%A1%E6%89%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2024-10-17T06:46:15.000Z" itemprop="datePublished">2024-10-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>►<a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/">baosight</a>►<a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/OPC-UA/">OPC_UA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/17/OPCUA%E6%8F%A1%E6%89%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/">OPCUA握手的简单实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ol>
<li>客户端向服务端发生自己的公钥，用私钥加签</li>
<li>服务端向客户端发生自己的公钥，用私钥加签</li>
<li>客户端和服务端协商一个对称秘钥，用一方的私钥加签，另一方公钥加密后传输</li>
<li>用对称秘钥加密，发送方私钥加签传输消息</li>
</ol>
<p>这里的1，2在opcua是通过openSecureChannel之前的一些消息交换完成的，3可以看做SecureChannel上面进行的，4可以看做Session上面进行的</p>
<h2 id="Client-cpp"><a href="#Client-cpp" class="headerlink" title="Client.cpp"></a>Client.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/rsa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/rand.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建Socket</span></span><br><span class="line">    <span class="keyword">if</span> ((sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Socket creation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Invalid address / Address not supported&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Connection failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 生成客户端密钥对</span></span><br><span class="line">    RSA* clientKeyPair = <span class="built_in">generateKeyPair</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成客户端公钥</span></span><br><span class="line">    std::string clientPubKeyStr = <span class="built_in">getPublicKey</span>(clientKeyPair);</span><br><span class="line">    std::string clientPriKeyStr = <span class="built_in">getPrivateKey</span>(clientKeyPair);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送公钥</span></span><br><span class="line">    <span class="built_in">sendData</span>(sock, <span class="built_in">convertPriKeyString2RSA</span>(clientPriKeyStr), clientPubKeyStr);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始 clientPubKey: \n&quot;</span> &lt;&lt; clientPubKeyStr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受服务器公钥</span></span><br><span class="line">    std::string* ret = <span class="built_in">receiveData</span>(sock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析服务器公钥</span></span><br><span class="line">    RSA* serverPubKey = <span class="built_in">convertPubKeyString2RSA</span>(ret[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!serverPubKey) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to read server&#x27;s public key&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证服务器签名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">verifySignature</span>(serverPubKey, <span class="built_in">sha256</span>(ret[<span class="number">0</span>]), ret[<span class="number">1</span>])) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server signature verified!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Server signature verification failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;解析 serverPubKey: &quot;</span> &lt;&lt; serverPubKey &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">receiveDataEN</span>(sock, <span class="built_in">convertPriKeyString2RSA</span>(clientPriKeyStr), serverPubKey);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sym key: &quot;</span> &lt;&lt; <span class="built_in">toHex</span>(ret[<span class="number">0</span>]) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证服务器签名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">verifySignature</span>(serverPubKey, <span class="built_in">sha256</span>(ret[<span class="number">0</span>]), ret[<span class="number">1</span>])) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server signature verified!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Server signature verification failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 客户端接收服务器加密的 &quot;hello&quot; 消息</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> iv[AES_BLOCK_SIZE];</span><br><span class="line">    <span class="built_in">read</span>(sock, iv, AES_BLOCK_SIZE);  <span class="comment">// 接收 IV</span></span><br><span class="line">    <span class="built_in">read</span>(sock, &amp;len, <span class="built_in">sizeof</span>(len));  <span class="comment">// 接收加密消息长度</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;iv: &quot;</span> &lt;&lt; <span class="built_in">toHex</span>(std::<span class="built_in">string</span>((<span class="type">char</span>*)iv, AES_BLOCK_SIZE)) &lt;&lt; std::endl;</span><br><span class="line">    len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">    <span class="built_in">read</span>(sock, buffer, len);  <span class="comment">// 接收加密消息</span></span><br><span class="line">    <span class="function">std::string <span class="title">encryptedMessage</span><span class="params">(buffer, len)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;en: &quot;</span> &lt;&lt; <span class="built_in">toHex</span>(encryptedMessage) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string aesKey = ret[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 用 AES 密钥解密消息</span></span><br><span class="line">    std::string decryptedMessage = <span class="built_in">aesDecrypt</span>(encryptedMessage, aesKey, iv);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Received decrypted message from server: &quot;</span> &lt;&lt; decryptedMessage &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="built_in">RSA_free</span>(clientKeyPair);</span><br><span class="line">    <span class="built_in">RSA_free</span>(serverPubKey);</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Server-cpp"><a href="#Server-cpp" class="headerlink" title="Server.cpp"></a>Server.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/rand.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleClient</span><span class="params">(<span class="type">int</span> clientSocket)</span> </span>&#123;</span><br><span class="line">    std::string* ret = <span class="built_in">receiveData</span>(clientSocket);</span><br><span class="line">    std::string clientPubKeyStr = ret[<span class="number">0</span>];</span><br><span class="line">    std::string clientSignature = ret[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析客户端公钥</span></span><br><span class="line">    RSA* clientPubKey = <span class="built_in">convertPubKeyString2RSA</span>(clientPubKeyStr);</span><br><span class="line">    <span class="keyword">if</span> (!clientPubKey) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to read client&#x27;s public key&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证签名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">verifySignature</span>(clientPubKey, <span class="built_in">sha256</span>(clientPubKeyStr), clientSignature)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Client signature verified!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Client signature verification failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始 clientPubKey: \n&quot;</span> &lt;&lt; clientPubKeyStr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成服务器密钥对</span></span><br><span class="line">    RSA* serverKeyPair = <span class="built_in">generateKeyPair</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成服务器公钥</span></span><br><span class="line">    std::string serverPubKeyStr = <span class="built_in">getPublicKey</span>(serverKeyPair);</span><br><span class="line">    std::string serverPriKeyStr = <span class="built_in">getPrivateKey</span>(serverKeyPair);</span><br><span class="line">    <span class="built_in">sendData</span>(clientSocket, <span class="built_in">convertPriKeyString2RSA</span>(serverPriKeyStr), serverPubKeyStr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始 serverPubKey: \n&quot;</span> &lt;&lt; serverPubKeyStr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机 AES 密钥</span></span><br><span class="line">    std::string aesKey = <span class="built_in">generateAESKey</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Generated AES key (Hex): &quot;</span> &lt;&lt; <span class="built_in">toHex</span>(aesKey) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; aesKey.<span class="built_in">length</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用客户端公钥加密，用服务端私钥解密</span></span><br><span class="line">    <span class="built_in">sendDataEN</span>(clientSocket, clientPubKey, <span class="built_in">convertPriKeyString2RSA</span>(serverPriKeyStr), aesKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 服务端发送加密的 &quot;hello&quot; 消息</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> iv[AES_BLOCK_SIZE];</span><br><span class="line">    <span class="built_in">RAND_bytes</span>(iv, AES_BLOCK_SIZE);  <span class="comment">// 生成随机 IV</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;iv: &quot;</span> &lt;&lt; <span class="built_in">toHex</span>(std::<span class="built_in">string</span>((<span class="type">char</span>*)iv, AES_BLOCK_SIZE)) &lt;&lt; std::endl;</span><br><span class="line">    std::string message = <span class="string">&quot;hello client!!&quot;</span>;</span><br><span class="line">    std::string encryptedMessage = <span class="built_in">aesEncrypt</span>(message, aesKey, iv);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;en: &quot;</span> &lt;&lt; <span class="built_in">toHex</span>(encryptedMessage) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 IV 和加密的消息</span></span><br><span class="line">    <span class="built_in">send</span>(clientSocket, iv, AES_BLOCK_SIZE, <span class="number">0</span>);  <span class="comment">// 发送 IV</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">htonl</span>(encryptedMessage.<span class="built_in">length</span>());</span><br><span class="line">    <span class="built_in">send</span>(clientSocket, &amp;len, <span class="built_in">sizeof</span>(len), <span class="number">0</span>);  <span class="comment">// 发送加密消息长度</span></span><br><span class="line">    <span class="built_in">send</span>(clientSocket, encryptedMessage.<span class="built_in">c_str</span>(), encryptedMessage.<span class="built_in">length</span>(), <span class="number">0</span>);  <span class="comment">// 发送加密消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="built_in">RSA_free</span>(clientPubKey);</span><br><span class="line">    <span class="built_in">RSA_free</span>(serverKeyPair);</span><br><span class="line">    <span class="built_in">close</span>(clientSocket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> serverFd, clientSocket;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建Socket</span></span><br><span class="line">    <span class="keyword">if</span> ((serverFd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Socket creation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serverFd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Bind failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serverFd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Listen failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server listening on port &quot;</span> &lt;&lt; PORT &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待客户端连接</span></span><br><span class="line">    <span class="keyword">if</span> ((clientSocket = <span class="built_in">accept</span>(serverFd, (<span class="keyword">struct</span> sockaddr*)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Accept failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Client connect on port &quot;</span> &lt;&lt; PORT &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端</span></span><br><span class="line">    <span class="built_in">handleClient</span>(clientSocket);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(serverFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Common-h"><a href="#Common-h" class="headerlink" title="Common.h"></a>Common.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/aes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/rsa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/rand.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/sha.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成AES秘钥</span></span><br><span class="line"><span class="function">std::string <span class="title">generateAESKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> aesKey[<span class="number">32</span>];  <span class="comment">// 256-bit AES key</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">RAND_bytes</span>(aesKey, <span class="built_in">sizeof</span>(aesKey))) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error generating AES key&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>((<span class="type">char</span>*)aesKey, <span class="built_in">sizeof</span>(aesKey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成keyPair</span></span><br><span class="line"><span class="function">RSA* <span class="title">generateKeyPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RSA* rsa = <span class="built_in">RSA_new</span>();</span><br><span class="line">    BIGNUM* bn = <span class="built_in">BN_new</span>();</span><br><span class="line">    <span class="built_in">BN_set_word</span>(bn, RSA_F4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">RSA_generate_key_ex</span>(rsa, <span class="number">1024</span>, bn, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error generating key pair&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">ERR_print_errors_fp</span>(stderr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rsa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从keyPair生成公钥</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getPublicKey</span><span class="params">(RSA* keyPair)</span> </span>&#123;</span><br><span class="line">	<span class="type">size_t</span> pub_len = <span class="number">0</span>; <span class="comment">// 公钥长度</span></span><br><span class="line">	<span class="type">char</span> *pri_key = <span class="literal">nullptr</span>; <span class="comment">// 私钥</span></span><br><span class="line">	<span class="type">char</span> *pub_key = <span class="literal">nullptr</span>; <span class="comment">// 公钥</span></span><br><span class="line">	BIO *pub = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());</span><br><span class="line">	<span class="built_in">PEM_write_bio_RSA_PUBKEY</span>(pub, keyPair);</span><br><span class="line">	pub_len = <span class="built_in">BIO_pending</span>(pub);</span><br><span class="line">	pub_key = (<span class="type">char</span> *)<span class="built_in">malloc</span>(pub_len + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">BIO_read</span>(pub, pub_key, pub_len);</span><br><span class="line">	pub_key[pub_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> pub_key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从keyPair生成私钥</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getPrivateKey</span><span class="params">(RSA* keyPair)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> pub_len = <span class="number">0</span>; <span class="comment">// 公钥长度</span></span><br><span class="line">	<span class="type">char</span> *pri_key = <span class="literal">nullptr</span>; <span class="comment">// 私钥</span></span><br><span class="line">	BIO *pri = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());</span><br><span class="line">	<span class="built_in">PEM_write_bio_RSAPrivateKey</span>(pri, keyPair, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	pub_len = <span class="built_in">BIO_pending</span>(pri);</span><br><span class="line">	pri_key = (<span class="type">char</span> *)<span class="built_in">malloc</span>(pub_len + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">BIO_read</span>(pri, pri_key, pub_len);</span><br><span class="line">	pri_key[pub_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> pri_key;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把公钥String转为RSA*格式</span></span><br><span class="line"><span class="function">RSA* <span class="title">convertPubKeyString2RSA</span> <span class="params">(std::string keyStr)</span> </span>&#123;</span><br><span class="line">    BIO *keybio = <span class="built_in">BIO_new_mem_buf</span>((<span class="type">unsigned</span> <span class="type">char</span> *)keyStr.<span class="built_in">c_str</span>(), <span class="number">-1</span>);</span><br><span class="line">	RSA *rsa = <span class="built_in">RSA_new</span>();</span><br><span class="line">	rsa = <span class="built_in">PEM_read_bio_RSA_PUBKEY</span>(keybio, &amp;rsa, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">BIO_free</span>(keybio);</span><br><span class="line">    <span class="keyword">return</span> rsa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把私钥String转为RSA*格式</span></span><br><span class="line"><span class="function">RSA* <span class="title">convertPriKeyString2RSA</span> <span class="params">(std::string keyStr)</span> </span>&#123;</span><br><span class="line">	BIO *keybio = <span class="built_in">BIO_new_mem_buf</span>((<span class="type">unsigned</span> <span class="type">char</span> *)keyStr.<span class="built_in">c_str</span>(), <span class="number">-1</span>);</span><br><span class="line">	RSA* rsa = <span class="built_in">RSA_new</span>();</span><br><span class="line">	rsa = <span class="built_in">PEM_read_bio_RSAPrivateKey</span>(keybio, &amp;rsa, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">BIO_free</span>(keybio);</span><br><span class="line">    <span class="keyword">return</span> rsa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 RSA* 公钥写入文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writePublicKeyToFile</span><span class="params">(RSA* rsaPrivateKey, <span class="type">const</span> std::string&amp; fileName)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;写入公钥：&quot;</span> &lt;&lt; rsaPrivateKey &lt;&lt; std::endl;</span><br><span class="line">    FILE* publicKeyFile = <span class="built_in">fopen</span>(fileName.<span class="built_in">c_str</span>(), <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!publicKeyFile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to open public key file!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">RSA_free</span>(rsaPrivateKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 PEM_write_RSA_PUBKEY 提取并写入公钥</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PEM_write_RSA_PUBKEY</span>(publicKeyFile, rsaPrivateKey)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error writing public key!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">ERR_print_errors_fp</span>(stderr);</span><br><span class="line">        <span class="built_in">fclose</span>(publicKeyFile);</span><br><span class="line">        <span class="built_in">RSA_free</span>(rsaPrivateKey);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取公钥字符串</span></span><br><span class="line"><span class="function">std::string <span class="title">readPublicKeyFromFile</span><span class="params">(<span class="type">const</span> std::string&amp; fileName)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件读取公钥&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">publicKeyStr</span><span class="params">((std::istreambuf_iterator&lt;<span class="type">char</span>&gt;(file)),</span></span></span><br><span class="line"><span class="params"><span class="function">                              std::istreambuf_iterator&lt;<span class="type">char</span>&gt;())</span></span>;</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> publicKeyStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串转换回 RSA* 公钥</span></span><br><span class="line"><span class="function">RSA* <span class="title">stringToRSA</span><span class="params">(<span class="type">const</span> std::string&amp; publicKeyStr)</span> </span>&#123;</span><br><span class="line">    BIO* bio = <span class="built_in">BIO_new_mem_buf</span>(publicKeyStr.<span class="built_in">c_str</span>(), <span class="number">-1</span>);  <span class="comment">// 创建 BIO 缓冲区</span></span><br><span class="line">    RSA* rsaPublicKey = <span class="built_in">PEM_read_bio_RSA_PUBKEY</span>(bio, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">BIO_free</span>(bio);  <span class="comment">// 释放 BIO 缓冲区</span></span><br><span class="line">    <span class="keyword">return</span> rsaPublicKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SHA256 hash</span></span><br><span class="line"><span class="comment">// ---- sha256摘要哈希 ---- //    </span></span><br><span class="line"><span class="function">std::string <span class="title">sha256</span><span class="params">(<span class="type">const</span> std::string &amp;srcStr)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 调用sha256哈希    </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mdStr[<span class="number">33</span>] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line">    <span class="built_in">SHA256</span>((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)srcStr.<span class="built_in">c_str</span>(), srcStr.<span class="built_in">length</span>(), mdStr);  </span><br><span class="line">    <span class="comment">// 哈希后的字符串    </span></span><br><span class="line">    std::string encodedStr = std::<span class="built_in">string</span>((<span class="type">const</span> <span class="type">char</span> *)mdStr);  </span><br><span class="line">    <span class="comment">// 哈希后的十六进制串 32字节    </span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">65</span>] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%02x&quot;</span>, mdStr[i]);  </span><br><span class="line">        <span class="built_in">strcat</span>(buf, tmp);  </span><br><span class="line">    &#125;  </span><br><span class="line">    buf[<span class="number">32</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 后面都是0，从32字节截断    </span></span><br><span class="line">    encodedStr = std::<span class="built_in">string</span>(buf);  </span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;hashed key: &quot; &lt;&lt; encodedStr &lt;&lt; &quot; &quot; &lt;&lt; encodedStr.length() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">return</span> encodedStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string转16进制</span></span><br><span class="line"><span class="function">std::string <span class="title">toHex</span><span class="params">(<span class="type">const</span> std::string&amp; input)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* hex_digits = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line">    std::string output;</span><br><span class="line">    output.<span class="built_in">reserve</span>(input.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> c : input) &#123;</span><br><span class="line">        output.<span class="built_in">push_back</span>(hex_digits[c &gt;&gt; <span class="number">4</span>]);</span><br><span class="line">        output.<span class="built_in">push_back</span>(hex_digits[c &amp; <span class="number">15</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base64编码</span></span><br><span class="line"><span class="function">std::string <span class="title">base64_encode</span><span class="params">(<span class="type">const</span> std::string&amp; input)</span> </span>&#123;</span><br><span class="line">    BIO *bio, *b64;</span><br><span class="line">    BUF_MEM *bufferPtr;</span><br><span class="line">    </span><br><span class="line">    b64 = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_f_base64</span>());</span><br><span class="line">    bio = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());</span><br><span class="line">    <span class="built_in">BIO_set_flags</span>(b64, BIO_FLAGS_BASE64_NO_NL); <span class="comment">// 不要添加换行符</span></span><br><span class="line">    bio = <span class="built_in">BIO_push</span>(b64, bio);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BIO_write</span>(bio, input.<span class="built_in">c_str</span>(), input.<span class="built_in">length</span>());</span><br><span class="line">    <span class="built_in">BIO_flush</span>(bio);</span><br><span class="line">    <span class="built_in">BIO_get_mem_ptr</span>(bio, &amp;bufferPtr);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">output</span><span class="params">(bufferPtr-&gt;data, bufferPtr-&gt;length)</span></span>;</span><br><span class="line">    <span class="built_in">BIO_free_all</span>(bio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base64解码</span></span><br><span class="line"><span class="function">std::string <span class="title">base64_decode</span><span class="params">(<span class="type">const</span> std::string&amp; input)</span> </span>&#123;</span><br><span class="line">    BIO *bio, *b64;</span><br><span class="line">    <span class="type">char</span>* buffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(input.<span class="built_in">length</span>());</span><br><span class="line">    </span><br><span class="line">    b64 = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_f_base64</span>());</span><br><span class="line">    bio = <span class="built_in">BIO_new_mem_buf</span>(input.<span class="built_in">c_str</span>(), input.<span class="built_in">length</span>());</span><br><span class="line">    <span class="built_in">BIO_set_flags</span>(b64, BIO_FLAGS_BASE64_NO_NL); <span class="comment">// 不要添加换行符</span></span><br><span class="line">    bio = <span class="built_in">BIO_push</span>(b64, bio);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> decodedLength = <span class="built_in">BIO_read</span>(bio, buffer, input.<span class="built_in">length</span>());</span><br><span class="line">    <span class="function">std::string <span class="title">output</span><span class="params">(buffer, decodedLength)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BIO_free_all</span>(bio);</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用指定公钥加密</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptWithPublicKey</span><span class="params">(RSA* pubKey, std::string&amp; aesKey)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encryptedKey[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> encryptedLen = <span class="built_in">RSA_public_encrypt</span>(aesKey.<span class="built_in">size</span>(),</span><br><span class="line">                                          (<span class="type">unsigned</span> <span class="type">char</span>*)aesKey.<span class="built_in">c_str</span>(),</span><br><span class="line">                                          encryptedKey, pubKey, RSA_PKCS1_OAEP_PADDING);</span><br><span class="line">    <span class="keyword">if</span> (encryptedLen == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; aesKey.<span class="built_in">length</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error encrypting with public key&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">ERR_load_ERR_strings</span>();</span><br><span class="line">        <span class="built_in">ERR_load_crypto_strings</span>(); </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> ulErr = <span class="built_in">ERR_get_error</span>(); <span class="comment">// 获取错误号</span></span><br><span class="line">        <span class="type">char</span> szErrMsg[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">char</span> *pTmp = <span class="literal">NULL</span>;</span><br><span class="line">        pTmp = <span class="built_in">ERR_error_string</span>(ulErr,szErrMsg); <span class="comment">// 格式：error:errId:库:函数:原因</span></span><br><span class="line">        std::cout &lt;&lt; pTmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>((<span class="type">char</span>*)encryptedKey, encryptedLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用指定私钥解密 </span></span><br><span class="line"><span class="function">std::string <span class="title">decryptWithPrivateKey</span><span class="params">(RSA* privKey, std::string&amp; encryptedKey)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> decryptedKey[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> decryptedLen = <span class="built_in">RSA_private_decrypt</span>(encryptedKey.<span class="built_in">size</span>(),</span><br><span class="line">                                           (<span class="type">unsigned</span> <span class="type">char</span>*)encryptedKey.<span class="built_in">c_str</span>(),</span><br><span class="line">                                           decryptedKey, privKey, RSA_PKCS1_OAEP_PADDING);</span><br><span class="line">    <span class="keyword">if</span> (decryptedLen == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error decrypting with private key&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>((<span class="type">char</span>*)decryptedKey, decryptedLen);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包数据，添加签名</span></span><br><span class="line"><span class="function">std::string <span class="title">packageData</span><span class="params">(std::string str1, std::string str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1 + <span class="string">&quot;[&quot;</span> +str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成数据签名</span></span><br><span class="line"><span class="function">std::string <span class="title">signMessage</span><span class="params">(RSA* privateKey, <span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> signature[BUFFER_SIZE];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sig_len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RSA_sign</span>(NID_sha256, (<span class="type">unsigned</span> <span class="type">char</span>*)message.<span class="built_in">c_str</span>(), message.<span class="built_in">length</span>(), signature, &amp;sig_len, privateKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">string</span>((<span class="type">char</span>*)signature, sig_len);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Error signing message&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证签名</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">verifySignature</span><span class="params">(RSA* publicKey, <span class="type">const</span> std::string&amp; message, <span class="type">const</span> std::string&amp; signature)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RSA_verify</span>(NID_sha256, (<span class="type">unsigned</span> <span class="type">char</span>*)message.<span class="built_in">c_str</span>(), message.<span class="built_in">length</span>(), (<span class="type">unsigned</span> <span class="type">char</span>*)signature.<span class="built_in">c_str</span>(), signature.<span class="built_in">length</span>(), publicKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送类opcua数据包(不加密)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendData</span><span class="params">(<span class="type">int</span> socket, RSA* privateKey, std::string message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先生成签名</span></span><br><span class="line">    std::string sign = <span class="built_in">signMessage</span>(privateKey, <span class="built_in">sha256</span>(message));</span><br><span class="line">    <span class="comment">// 添加padding并加密</span></span><br><span class="line">    <span class="comment">// TODO：查查padding是怎么实现的，这里暂时是一个分割符号</span></span><br><span class="line">    std::string sendMessage = <span class="built_in">packageData</span>(message, sign); </span><br><span class="line">    <span class="type">int</span> messageLen = <span class="built_in">htonl</span>(sendMessage.<span class="built_in">length</span>());</span><br><span class="line">    <span class="comment">// 发送打包后的数据</span></span><br><span class="line">    <span class="comment">// 先发送长度</span></span><br><span class="line">    <span class="built_in">send</span>(socket, &amp;messageLen, <span class="built_in">sizeof</span>(messageLen), <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">// 发送实际数据</span></span><br><span class="line">    <span class="built_in">send</span>(socket, sendMessage.<span class="built_in">c_str</span>(), sendMessage.<span class="built_in">length</span>(), <span class="number">0</span>);  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受包(不解密)</span></span><br><span class="line"><span class="function">std::string* <span class="title">receiveData</span><span class="params">(<span class="type">int</span> socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取总长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">read</span>(socket, &amp;len, <span class="built_in">sizeof</span>(len));</span><br><span class="line">    <span class="comment">// 接受整个包</span></span><br><span class="line">    len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">read</span>(socket, buffer, len);  <span class="comment">// 接收实际数据</span></span><br><span class="line">    <span class="function">std::string <span class="title">data</span><span class="params">(buffer, len)</span></span>;</span><br><span class="line">    <span class="comment">// 分割数据和签名</span></span><br><span class="line">    <span class="comment">// 假设公钥和签名用特殊字符分隔（如&#x27;|&#x27;)</span></span><br><span class="line">    <span class="type">size_t</span> delimiterPos = data.<span class="built_in">find</span>(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    std::string bodyStr = data.<span class="built_in">substr</span>(<span class="number">0</span>, delimiterPos);</span><br><span class="line">    std::string signature = data.<span class="built_in">substr</span>(delimiterPos + <span class="number">1</span>);</span><br><span class="line">    <span class="type">static</span> std::string res[<span class="number">2</span>] = &#123;bodyStr, signature&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送类opcua数据包(包括加密)</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 暂时改成不加密签名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendDataEN</span><span class="params">(<span class="type">int</span> socket, RSA* publicKey, RSA* privateKey, std::string message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先生成签名</span></span><br><span class="line">    std::string sign = <span class="built_in">signMessage</span>(privateKey, <span class="built_in">sha256</span>(message));</span><br><span class="line">    <span class="comment">// 添加padding并加密</span></span><br><span class="line">    <span class="comment">// TODO：查查padding是怎么实现的，这里暂时是一个分割符号</span></span><br><span class="line">    std::string sendMessage = <span class="built_in">encryptWithPublicKey</span>(publicKey, message);</span><br><span class="line">    sendMessage = <span class="built_in">base64_encode</span>(<span class="built_in">packageData</span>(sendMessage, sign));</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;data len: &quot; &lt;&lt; sendMessage.length() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="type">int</span> messageLen = <span class="built_in">htonl</span>(sendMessage.<span class="built_in">length</span>());</span><br><span class="line">    <span class="comment">// 发送打包后的数据</span></span><br><span class="line">    <span class="comment">// 先发送长度</span></span><br><span class="line">    <span class="built_in">send</span>(socket, &amp;messageLen, <span class="built_in">sizeof</span>(messageLen), <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">// 发送实际数据</span></span><br><span class="line">    <span class="built_in">send</span>(socket, sendMessage.<span class="built_in">c_str</span>(), sendMessage.<span class="built_in">length</span>(), <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;sendMessage: &quot; &lt;&lt; sendMessage &lt;&lt; std::endl;</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受包(包括解密)</span></span><br><span class="line"><span class="function">std::string* <span class="title">receiveDataEN</span><span class="params">(<span class="type">int</span> socket, RSA* privateKey, RSA* publicKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取总长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">read</span>(socket, &amp;len, <span class="built_in">sizeof</span>(len));</span><br><span class="line">    <span class="comment">// 接受整个包</span></span><br><span class="line">    len = <span class="built_in">ntohl</span>(len);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;data len: &quot; &lt;&lt; len &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">read</span>(socket, buffer, len);  <span class="comment">// 接收实际数据</span></span><br><span class="line">    <span class="function">std::string <span class="title">data</span><span class="params">(buffer, len)</span></span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;data: &quot; &lt;&lt; data &lt;&lt; std::endl;</span></span><br><span class="line">    data = <span class="built_in">base64_decode</span>(data);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;data: &quot; &lt;&lt; data &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// 分割数据和签名</span></span><br><span class="line">    <span class="comment">// 假设公钥和签名用特殊字符分隔（如&#x27;|&#x27;)</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>这个分隔符号是不合理的，可能失败</span></span><br><span class="line">    <span class="type">size_t</span> delimiterPos = data.<span class="built_in">find</span>(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    std::string bodyStr = data.<span class="built_in">substr</span>(<span class="number">0</span>, delimiterPos);</span><br><span class="line">    std::string signature = data.<span class="built_in">substr</span>(delimiterPos + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    std::string decryptData = <span class="built_in">decryptWithPrivateKey</span>(privateKey, bodyStr);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;解密：&quot; &lt;&lt; decryptData &lt;&lt; std::endl; </span></span><br><span class="line">    <span class="type">static</span> std::string res[<span class="number">2</span>] = &#123;decryptData, signature&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AES加密</span></span><br><span class="line"><span class="function">std::string <span class="title">aesEncrypt</span><span class="params">(<span class="type">const</span> std::string&amp; plaintext, <span class="type">const</span> std::string&amp; key, <span class="type">unsigned</span> <span class="type">char</span>* iv)</span> </span>&#123;</span><br><span class="line">    EVP_CIPHER_CTX* ctx = <span class="built_in">EVP_CIPHER_CTX_new</span>();</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> ciphertext_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ciphertext[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EVP_EncryptInit_ex</span>(ctx, <span class="built_in">EVP_aes_256_cbc</span>(), <span class="literal">NULL</span>, (<span class="type">unsigned</span> <span class="type">char</span>*)key.<span class="built_in">c_str</span>(), iv);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EVP_EncryptUpdate</span>(ctx, ciphertext, &amp;len, (<span class="type">unsigned</span> <span class="type">char</span>*)plaintext.<span class="built_in">c_str</span>(), plaintext.<span class="built_in">length</span>());</span><br><span class="line">    ciphertext_len = len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EVP_EncryptFinal_ex</span>(ctx, ciphertext + len, &amp;len);</span><br><span class="line">    ciphertext_len += len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EVP_CIPHER_CTX_free</span>(ctx);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>((<span class="type">char</span>*)ciphertext, ciphertext_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AES解密</span></span><br><span class="line"><span class="function">std::string <span class="title">aesDecrypt</span><span class="params">(<span class="type">const</span> std::string&amp; ciphertext, <span class="type">const</span> std::string&amp; key, <span class="type">unsigned</span> <span class="type">char</span>* iv)</span> </span>&#123;</span><br><span class="line">    EVP_CIPHER_CTX* ctx = <span class="built_in">EVP_CIPHER_CTX_new</span>();</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> plaintext_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> plaintext[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EVP_DecryptInit_ex</span>(ctx, <span class="built_in">EVP_aes_256_cbc</span>(), <span class="literal">NULL</span>, (<span class="type">unsigned</span> <span class="type">char</span>*)key.<span class="built_in">c_str</span>(), iv);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret1 = <span class="built_in">EVP_DecryptUpdate</span>(ctx, plaintext, &amp;len, (<span class="type">unsigned</span> <span class="type">char</span>*)ciphertext.<span class="built_in">c_str</span>(), ciphertext.<span class="built_in">length</span>());</span><br><span class="line">    plaintext_len = len;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;EVP_DecryptUpdate:&quot;</span> &lt;&lt; ret1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">EVP_DecryptFinal_ex</span>(ctx, plaintext + len, &amp;len);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;EVP_DecryptFinal_ex:&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">    plaintext_len += len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret1 * ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ERR_print_errors_fp</span>(stderr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EVP_CIPHER_CTX_free</span>(ctx);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>((<span class="type">char</span>*)plaintext, plaintext_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/17/OPCUA%E6%8F%A1%E6%89%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/" data-id="cm2cy94mu0000xsvcbcpx72lt" data-title="OPCUA握手的简单实现" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LCR119/">LCR119</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/">LeetCode101</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E5%9B%9E%E6%BA%AF/">回溯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">深度优先搜索</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Makefile/">Makefile</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/REDIS/">REDIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/">Dubbo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Kafka/">Kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/MIT-6824/">MIT-6824</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RabbitMQ/">RabbitMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RocketMQ/">RocketMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/TypeScript/">TypeScript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/">baosight</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/OPC-UA/">OPC_UA</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/">网络系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/">日常开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/ImageMatchingfromHandcraftedtoDeepFeatures-ASurvey/">ImageMatchingfromHandcraftedtoDeepFeatures:ASurvey</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/">分治</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">常用算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">软件设计</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/%E6%8F%8F%E8%BF%B0%E4%B8%8E%E9%9D%A2%E8%AF%95/">描述与面试</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/07/AI%E5%B0%8F%E8%AF%B4/">AI小说</a>
          </li>
        
          <li>
            <a href="/2024/12/07/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a>
          </li>
        
          <li>
            <a href="/2024/12/02/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a>
          </li>
        
          <li>
            <a href="/2024/12/01/Kafka/">Kafka</a>
          </li>
        
          <li>
            <a href="/2024/11/30/RabbitMQ/">RabbitMQ</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>