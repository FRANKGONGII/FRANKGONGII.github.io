<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LeetCode刷题-滑动窗口 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="典型2831 定长窗口什么时候可以用定长窗口？“长度”至少为k的情况下满足最少最小，或者指定“长度”为k  模版：初始化，填充满第一个窗口 - 入 - 操作 - 出  1456 定长子串中元音的最大数目 给你字符串 s 和整数 k 。请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。英文中的 元音字母 为（a, e, i, o, u）。  思路：经典的(初始化) - 入 -">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode刷题-滑动窗口">
<meta property="og:url" content="http://example.com/2025/02/27/LeetCode%E5%88%B7%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="典型2831 定长窗口什么时候可以用定长窗口？“长度”至少为k的情况下满足最少最小，或者指定“长度”为k  模版：初始化，填充满第一个窗口 - 入 - 操作 - 出  1456 定长子串中元音的最大数目 给你字符串 s 和整数 k 。请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。英文中的 元音字母 为（a, e, i, o, u）。  思路：经典的(初始化) - 入 -">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/02/27/LeetCode%E5%88%B7%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/image.png">
<meta property="article:published_time" content="2025-02-27T03:34:44.000Z">
<meta property="article:modified_time" content="2025-03-18T01:48:44.600Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/02/27/LeetCode%E5%88%B7%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/image.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-LeetCode刷题-滑动窗口" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/27/LeetCode%E5%88%B7%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" class="article-date">
  <time class="dt-published" datetime="2025-02-27T03:34:44.000Z" itemprop="datePublished">2025-02-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</a>►<a class="article-category-link" href="/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      LeetCode刷题-滑动窗口
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="典型"><a href="#典型" class="headerlink" title="典型"></a>典型</h1><p>2831</p>
<h1 id="定长窗口"><a href="#定长窗口" class="headerlink" title="定长窗口"></a>定长窗口</h1><p>什么时候可以用定长窗口？“长度”至少为k的情况下满足最少最小，或者指定“长度”为k</p>
<ul>
<li>模版：<strong>初始化，填充满第一个窗口 - 入 - 操作 - 出</strong></li>
</ul>
<h2 id="1456-定长子串中元音的最大数目"><a href="#1456-定长子串中元音的最大数目" class="headerlink" title="1456 定长子串中元音的最大数目"></a>1456 定长子串中元音的最大数目</h2><ul>
<li><p>给你字符串 s 和整数 k 。<br>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。<br>英文中的 元音字母 为（a, e, i, o, u）。</p>
</li>
<li><p>思路：<strong>经典的(初始化) - 入 - 更新 - 出</strong>，需要注意的是不要忘了窗口长度等于整个数组长度的情况，可能要在这种情况下及时更新结果</p>
</li>
<li><p>一个有意思的小技巧是把string转成char[]更快一点，取出下标比charAt快</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxVowels</span><span class="params">(String S, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">vowel</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 1. 进入窗口</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span> || s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;i&#x27;</span> || s[i] == <span class="string">&#x27;o&#x27;</span> || s[i] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                vowel++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) &#123; <span class="comment">// 窗口大小不足 k</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 更新答案</span></span><br><span class="line">            ans = Math.max(ans, vowel);</span><br><span class="line">            <span class="comment">// 3. 离开窗口</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">out</span> <span class="operator">=</span> s[i - k + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (out == <span class="string">&#x27;a&#x27;</span> || out == <span class="string">&#x27;e&#x27;</span> || out == <span class="string">&#x27;i&#x27;</span> || out == <span class="string">&#x27;o&#x27;</span> || out == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                vowel--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2841-几乎唯一数组的最大和"><a href="#2841-几乎唯一数组的最大和" class="headerlink" title="2841 几乎唯一数组的最大和"></a>2841 几乎唯一数组的最大和</h2><ul>
<li>给你一个整数数组 nums 和两个正整数 m 和 k 。请你返回 nums 中长度为 k 的 几乎唯一 子数组的 最大和 ，如果不存在几乎唯一子数组，请你返回 0 。如果 nums 的一个子数组有至少 m 个互不相同的元素，我们称它是几乎唯一子数组。子数组指的是一个数组中一段连续 非空 的元素序列。</li>
<li>思路：结合了经典定长窗口模式和map操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxSum</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> m, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now_sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">                now_sum += nums.get(i);</span><br><span class="line">                cnt.put(nums.get(i), cnt.getOrDefault(nums.get(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">outIndex</span> <span class="operator">=</span> i - k;</span><br><span class="line">                <span class="keyword">if</span> (cnt.keySet().size() &gt;= m) &#123;</span><br><span class="line">                    ret = Math.max(ret, now_sum);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (cnt.get(nums.get(outIndex)) == <span class="number">1</span>) &#123;</span><br><span class="line">                    cnt.remove(nums.get(outIndex));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt.put(nums.get(outIndex), cnt.get(nums.get(outIndex)) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cnt.put(nums.get(i), cnt.getOrDefault(nums.get(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                now_sum -= nums.get(outIndex);</span><br><span class="line">                now_sum += nums.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt.keySet().size() &gt;= m) &#123;</span><br><span class="line">            ret = Math.max(ret, now_sum);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2134-最少次数交换所有1"><a href="#2134-最少次数交换所有1" class="headerlink" title="2134 最少次数交换所有1"></a>2134 最少次数交换所有1</h2><ul>
<li>交换定义为选中一个数组中的两个互不相同的位置并交换二者的值。环形数组是一个数组，可以认为第一个元素和最后一个元素相邻。给你一个二进制环形数组nums ，返回在任意位置将数组中的所有1聚集在一起需要的最少交换次数。</li>
<li>思路：比较好想的是直接拓展3倍，然后用1个数的滑动窗口。当然也可以不扩大数组：当起始位置从 i−1 增加到 i 时，nums[i−1] 被从区间内移除，而 nums[(i+cnt−1) mod n] 被加入区间内。因此如果前者为 0，就将 0 的个数减少 1；如果后者为 0，就将 0 的个数增加 1。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwaps</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 00001111000111100000</span></span><br><span class="line">        <span class="comment">// 3 + 4 + 5 + 6</span></span><br><span class="line">        <span class="comment">// 先找到包含所有1的最短</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">one_cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] new_nums = <span class="keyword">new</span> <span class="title class_">int</span>[len * <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                new_nums[len * i + j] = nums[j];</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    one_cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(new_nums) + &quot; &quot; + one_cnt/3);</span></span><br><span class="line">        one_cnt /= <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">now_sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; new_nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; one_cnt) &#123;</span><br><span class="line">                now_sum += new_nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="type">int</span> <span class="variable">outIndex</span> <span class="operator">=</span> i - one_cnt;</span><br><span class="line">            max_sum = Math.max(max_sum, now_sum);</span><br><span class="line">            now_sum -= new_nums[outIndex];</span><br><span class="line">            now_sum += new_nums[i];</span><br><span class="line">            max_sum = Math.max(max_sum, now_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(max_sum);</span></span><br><span class="line">        <span class="keyword">if</span> (max_sum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1 0 0 1 1 0 1 0 1</span></span><br><span class="line">        <span class="keyword">return</span> one_cnt - max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSwaps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">            cur += (<span class="number">1</span> - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                --cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[(i + cnt - <span class="number">1</span>) % n] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++cur;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1297-子串的最大出现次数"><a href="#1297-子串的最大出现次数" class="headerlink" title="1297 子串的最大出现次数"></a>1297 子串的最大出现次数</h2><ul>
<li>给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：<br>子串中不同字母的数目必须小于等于 maxLetters 。<br>子串的长度必须大于等于 minSize 且小于等于 maxSize 。</li>
<li>思路：关键是想到只需要考虑minSize的子串：假设字符串 T 在给定的字符串 S 中出现的次数为 k，那么 T 的任意一个子串出现的次数至少也为 k，即 T 的任意一个子串在 S 中出现的次数不会少于 T 本身。这样我们就可以断定，在所有满足条件且出现次数最多的的字符串中，一定有一个的长度恰好为 minSize。我们可以使用反证法证明上述的结论：假设所有满足条件且出现次数最多的字符串中没有长度为 minSize 的，不妨任取其中的一个长度为 l 的字符串，根据假设，有 l &gt; minSize。此时我们再任取该字符串的一个长度为 minSize 的子串，子串出现的次数不会少于原字符串出现的次数，与假设相矛盾。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxFreq</span><span class="params">(String s, <span class="type">int</span> maxLetters, <span class="type">int</span> minSize, <span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        Map&lt;String, Integer&gt; cntString = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">tarLen</span> <span class="operator">=</span> minSize; tarLen &lt;= minSize; tarLen++) &#123;</span><br><span class="line">            map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; tarLen) &#123;</span><br><span class="line">                    map.put(s.charAt(i), map.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i == tarLen - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (map.keySet().size() &lt;= maxLetters) &#123;</span><br><span class="line">                            cntString.put(s.substring(<span class="number">0</span>, tarLen), <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">outChar</span> <span class="operator">=</span> s.charAt(i - tarLen);</span><br><span class="line">                <span class="keyword">if</span> (map.get(outChar) == <span class="number">1</span>) &#123;</span><br><span class="line">                    map.remove(outChar);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(outChar, map.get(outChar) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(s.charAt(i), map.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.keySet().size() &lt;= maxLetters) &#123;</span><br><span class="line">                    cntString.put(s.substring(i - tarLen + <span class="number">1</span>, i + <span class="number">1</span>), </span><br><span class="line">                    cntString.getOrDefault(s.substring(i - tarLen + <span class="number">1</span>, i + <span class="number">1</span>), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (String k : cntString.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cntString.get(k) &gt; max) &#123;</span><br><span class="line">                max = cntString.get(k);</span><br><span class="line">                ret = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2653-滑动子数组的美丽值"><a href="#2653-滑动子数组的美丽值" class="headerlink" title="2653 滑动子数组的美丽值"></a>2653 滑动子数组的美丽值</h2><ul>
<li>给你一个长度为 n 的整数数组 nums ，请你求出每个长度为 k 的子数组的 美丽值 。<br>一个子数组的 美丽值 定义为：如果子数组中第 x 小整数 是 负数 ，那么美丽值为第 x 小的数，否则美丽值为 0 。<br>请你返回一个包含 n - k + 1 个整数的数组，依次 表示数组中从第一个下标开始，每个长度为 k 的子数组的 美丽值 。<br>子数组指的是数组中一段连续 非空 的元素序列。</li>
<li>思路：一个关键点是数有范围，在-50-50，也就是说在子数组内查看数组内元素的出现情况是常数级别时间<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getSubarrayBeauty(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BIAS</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[BIAS * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123; <span class="comment">// 先往窗口内添加 k-1 个数</span></span><br><span class="line">            cnt[nums[i] + BIAS]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[nums[i] + BIAS]++; <span class="comment">// 进入窗口（保证窗口有恰好 k 个数）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> x;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; BIAS; j++) &#123; <span class="comment">// 暴力枚举负数范围 [-50,-1]</span></span><br><span class="line">                left -= cnt[j];</span><br><span class="line">                <span class="keyword">if</span> (left &lt;= <span class="number">0</span>) &#123; <span class="comment">// 找到美丽值</span></span><br><span class="line">                    ans[i - k + <span class="number">1</span>] = j - BIAS;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[nums[i - k + <span class="number">1</span>] + BIAS]--; <span class="comment">// 离开窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3439-重新安排会议得到最多时间"><a href="#3439-重新安排会议得到最多时间" class="headerlink" title="3439 重新安排会议得到最多时间"></a>3439 重新安排会议得到最多时间</h2><ul>
<li>给你一个整数 eventTime 表示一个活动的总时长，这个活动开始于 t &#x3D; 0 ，结束于 t &#x3D; eventTime 。<br>同时给你两个长度为 n 的整数数组 startTime 和 endTime 。它们表示这次活动中 n 个时间 没有重叠 的会议，其中第 i 个会议的时间为 [startTime[i], endTime[i]] 。<br>你可以重新安排 至多 k 个会议，安排的规则是将会议时间平移，且保持原来的 会议时长 ，你的目的是移动会议后 最大化 相邻两个会议之间的 最长 连续空余时间。<br>移动前后所有会议之间的 相对 顺序需要保持不变，而且会议时间也需要保持互不重叠。<br>请你返回重新安排会议以后，可以得到的 最大 空余时间。<br>注意，会议 不能 安排到整个活动的时间以外。</li>
<li>思路：详见注释<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxFreeTime</span><span class="params">(<span class="type">int</span> eventTime, <span class="type">int</span> k, <span class="type">int</span>[] startTime, <span class="type">int</span>[] endTime)</span> &#123;</span><br><span class="line">        <span class="comment">// 在移动k个会议的情况下获取最长的空闲时间</span></span><br><span class="line">        <span class="comment">// 会议之间不会重叠</span></span><br><span class="line">        <span class="comment">// 移动会议本质上是把一个会议左右的空闲时间合并，可以理解为把右侧加到了左侧</span></span><br><span class="line">        <span class="comment">// 那么显然应该尝试连续移动，连续移动k个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nowTime</span> <span class="operator">=</span> startTime[<span class="number">0</span>] - <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxTime</span> <span class="operator">=</span> startTime[<span class="number">0</span>] - <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">meetNum</span> <span class="operator">=</span> startTime.length;</span><br><span class="line">        <span class="comment">// 头尾加上两个节点</span></span><br><span class="line">        <span class="type">int</span>[] newStart = <span class="keyword">new</span> <span class="title class_">int</span>[meetNum + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[] newEnd = <span class="keyword">new</span> <span class="title class_">int</span>[meetNum + <span class="number">2</span>];</span><br><span class="line">        newStart[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        newEnd[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        newStart[meetNum + <span class="number">1</span>] = eventTime;</span><br><span class="line">        newEnd[meetNum + <span class="number">1</span>] = eventTime;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= meetNum; i++) &#123;</span><br><span class="line">            newStart[i] = startTime[i - <span class="number">1</span>];</span><br><span class="line">            newEnd[i] = endTime[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先移动k-1个, 也有可能不需要移动那么多</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">addTime</span> <span class="operator">=</span> i &lt;= meetNum ? newStart[i + <span class="number">1</span>] - newEnd[i] : <span class="number">0</span>;</span><br><span class="line">            nowTime += addTime;</span><br><span class="line">        &#125;</span><br><span class="line">        maxTime = Math.max(maxTime, nowTime);</span><br><span class="line">        <span class="comment">// 开始满足窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt;= meetNum ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">addTime</span> <span class="operator">=</span> newStart[i + <span class="number">1</span>] - newEnd[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">outTime</span> <span class="operator">=</span> newStart[i - k] - newEnd[i - k - <span class="number">1</span>];</span><br><span class="line">            nowTime += addTime;</span><br><span class="line">            nowTime -= outTime;</span><br><span class="line">            maxTime = Math.max(maxTime, nowTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="不定长窗口"><a href="#不定长窗口" class="headerlink" title="不定长窗口"></a>不定长窗口</h1><p>不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，以及求子数组个数。</p>
<ul>
<li>模版：两个指针，一个入新的元素，一个在满足条件后负责弹出元素。输入 - 满足情况下移出 - 判断</li>
<li>变化模版：取最左最右，那么中间的就可以作为窗口</li>
</ul>
<p>需要维护最大最小可以用treemap<br>有时只有最新一个元素会影响整体窗口情况，移动窗口可以只判断这个新的元素的影响</p>
<ul>
<li>下面是一个典型的例子：最简单的写法还是只写一个循环，也只用一个left指针控制窗口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子数组元素和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子数组左端点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++) &#123; <span class="comment">// 枚举子数组右端点</span></span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum - nums[left] &gt;= target) &#123; <span class="comment">// 尽量缩小子数组长度</span></span><br><span class="line">                sum -= nums[left++]; <span class="comment">// 左端点右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                ans = Math.min(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &lt;= n ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3090-每个字符最多出现两次的最长子字符串"><a href="#3090-每个字符最多出现两次的最长子字符串" class="headerlink" title="3090 每个字符最多出现两次的最长子字符串"></a>3090 每个字符最多出现两次的最长子字符串</h2><ul>
<li>给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该子字符串的最大长度。</li>
<li>思路：类似双指针，在满足条件后弹出元素，最外层还是循环控制好写一点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumLengthSubstring</span><span class="params">(String S)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> s[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 进入</span></span><br><span class="line">            cnt[b]++;</span><br><span class="line">            <span class="keyword">while</span> (cnt[b] &gt; <span class="number">2</span>) &#123; <span class="comment">// 移动到满足</span></span><br><span class="line">                cnt[s[left++] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, i - left + <span class="number">1</span>); <span class="comment">// 刚刚好满足的情况下处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1658-把x减小到0的最小操作数目"><a href="#1658-把x减小到0的最小操作数目" class="headerlink" title="1658 把x减小到0的最小操作数目"></a>1658 把x减小到0的最小操作数目</h2><ul>
<li>给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。</li>
<li>思路：还是经典双指针，但是要注意两个特殊判断：<code>sum&lt;x</code> 和 left 是否越界 – 其实就是不一定有窗口稳定态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xLeft</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; x) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            xLeft += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (xLeft &gt; sum - x &amp;&amp; left &lt; nums.length) &#123;</span><br><span class="line">                xLeft -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xLeft == sum - x) &#123;</span><br><span class="line">                min = Math.min(nums.length - (right - left + <span class="number">1</span>), min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? -<span class="number">1</span> :min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2779-数组的最大美丽值"><a href="#2779-数组的最大美丽值" class="headerlink" title="2779 数组的最大美丽值"></a>2779 数组的最大美丽值</h2><ul>
<li>给你一个下标从 0 开始的整数数组 nums 和一个 非负 整数 k 。在一步操作中，你可以执行下述指令：<br>在范围 [0, nums.length - 1] 中选择一个 此前没有选过 的下标 i 。将 nums[i] 替换为范围 [nums[i] - k, nums[i] + k] 内的任一整数。数组的 美丽值 定义为数组中由相等元素组成的最长子序列的长度。<br>对数组 nums 执行上述操作任意次后，返回数组可能取得的 最大 美丽值。注意：你 只 能对每个下标执行 一次 此操作。<br>数组的 子序列 定义是：经由原数组删除一些元素（也可能不删除）得到的一个新数组，且在此过程中剩余元素的顺序不发生改变。</li>
<li>思路1：半径2k的区间进出问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumBeauty</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 每一个数的替换范围是 [nums[i] - k, nums[i] + k]</span></span><br><span class="line">        <span class="comment">// 找到最大重复区间</span></span><br><span class="line">        <span class="comment">// 2k是半径</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowStart</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowEnd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowCnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                nowStart = nums[i] - k;</span><br><span class="line">                nowEnd = nums[i] + k;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newStart</span> <span class="operator">=</span> nums[i] - k;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newEnd</span> <span class="operator">=</span> nums[i] + k;</span><br><span class="line">            <span class="keyword">if</span> (newStart &gt; nowEnd) &#123;</span><br><span class="line">                <span class="comment">// 现在长度是nowCnt</span></span><br><span class="line">                <span class="comment">// 第一个是i - nowCnt，不断移出第一个知道满足</span></span><br><span class="line">                <span class="keyword">while</span> (newStart &gt; nums[i - nowCnt] + k) &#123;</span><br><span class="line">                    nowCnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                nowStart = newStart;</span><br><span class="line">                nowEnd = nums[i - nowCnt] + k;</span><br><span class="line">                nowCnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nowStart = newStart;</span><br><span class="line">                nowCnt++;</span><br><span class="line">                max = Math.max(max, nowCnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路2：因此题目等价于找到最大最小值之差小于等于 2k 的最长连续子数组，该子数组的长度即为数组的最大美丽值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumBeauty</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, n = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] - <span class="number">2</span> * k &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1838-最高频元素的频率"><a href="#1838-最高频元素的频率" class="headerlink" title="1838 最高频元素的频率"></a>1838 最高频元素的频率</h2><ul>
<li>元素的 频数 是该元素在一个数组中出现的次数。给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。</li>
<li>思路：排序 + 把每次进入窗口的作为要调整到的数字<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxFrequency</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowNum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowCnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextNum</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nowSum += (<span class="type">long</span>)(nowCnt) * (nextNum - nowNum);</span><br><span class="line">            <span class="keyword">while</span> (nowSum &gt; k) &#123;</span><br><span class="line">                nowSum -= (nextNum - nums[i - nowCnt]);</span><br><span class="line">                nowCnt--; </span><br><span class="line">            &#125;</span><br><span class="line">            nowCnt++;</span><br><span class="line">            nowNum = nextNum;</span><br><span class="line">            </span><br><span class="line">            max = (<span class="type">int</span>)Math.max(max, nowCnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2516-每种字符至少取k个"><a href="#2516-每种字符至少取k个" class="headerlink" title="2516 每种字符至少取k个"></a>2516 每种字符至少取k个</h2><ul>
<li>给你一个由字符 ‘a’、’b’、’c’ 组成的字符串 s 和一个非负整数 k 。每分钟，你可以选择取走 s 最左侧 还是 最右侧 的那个字符。你必须取走每种字符 至少 k 个，返回需要的 最少 分钟数；如果无法取到，则返回 -1 </li>
<li>思路：左右两侧至少取k个的最小长度 - 中间至多有ni-k个的最大长度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">takeCharacters</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 最少取走k个每种</span></span><br><span class="line">        <span class="comment">// 最长的至多ni-k个</span></span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : cs) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt[<span class="number">0</span>] &lt; k || cnt[<span class="number">1</span>] &lt; k || cnt[<span class="number">2</span>] &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] now = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; cs.length; right++) &#123;</span><br><span class="line">            now[cs[right] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">while</span> (now[cs[right] - <span class="string">&#x27;a&#x27;</span>] &gt; cnt[cs[right] - <span class="string">&#x27;a&#x27;</span>] - k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">                now[cs[left] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(right - left + <span class="number">1</span>, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max == -<span class="number">1</span> ? -<span class="number">1</span> : cs.length - max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2831-找出最长等值子数组"><a href="#2831-找出最长等值子数组" class="headerlink" title="2831 找出最长等值子数组"></a>2831 找出最长等值子数组</h2><ul>
<li>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。如果子数组中所有元素都相等，则认为子数组是一个 等值子数组 。注意，空数组是 等值子数组 。从 nums 中删除最多 k 个元素后，返回可能的最长等值子数组的长度。子数组 是数组中一个连续且可能为空的元素序列。</li>
<li>思路：找到一个窗口之后，只需要更大的窗口<br>关键点是：对于这种频率记录且要始终获取最大频率的问题，要先想想到底是不是真的一直需要当前最大频率，是不是可能只要历史最大频率就行了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestEqualSubarray</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        <span class="type">int</span>[] freq = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>]; <span class="comment">// 记录每个数字出现的频率</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxFreq</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前窗口内出现次数最多的数字的频率</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 左右指针</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums.get(right++); <span class="comment">// 获取当前右指针对应的数字，并右移</span></span><br><span class="line">            freq[num]++; <span class="comment">// 更新该数字的频率</span></span><br><span class="line">            maxFreq = Math.max(freq[num], maxFreq); <span class="comment">// 更新窗口内的最大频率</span></span><br><span class="line">            <span class="comment">// 这样理解：找到一个窗口之后，就只需要找更大的窗口</span></span><br><span class="line">            <span class="comment">// 如果进来的是一个原先的最高频率数字，不影响</span></span><br><span class="line">            <span class="comment">// 如果进来的是一个能出现新的最高频数字的数字，不影响，相当于判断左右+1</span></span><br><span class="line">            <span class="comment">// 如果进来的是一个其他数字，可能要去循环</span></span><br><span class="line">            <span class="comment">// 如果当前窗口长度减去最多频数字的次数超过允许替换的次数 k，缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (right - left  &gt; maxFreq + k) &#123;</span><br><span class="line">                freq[nums.get(left++)]--; <span class="comment">// 左指针右移，并减少移出数字的频率</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxFreq; <span class="comment">// 返回窗口内最多频数字的频率</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
还有一种类似双指针的思路：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：以当前结点为右边界，在确定其左边界</span></span><br><span class="line"><span class="comment">// 用cnt记录每个数的数量</span></span><br><span class="line"><span class="comment">// l表示左边界，r表示右边界</span></span><br><span class="line"><span class="comment">// 则r-l+1-cnt[nums[i]]就是窗口中非nums[i]的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">longestEqualSubarray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = numsSize;</span><br><span class="line">    <span class="type">int</span> cnt[n + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">        cnt[nums[r]]++;</span><br><span class="line">        <span class="comment">// 什么时候淘汰左边界？</span></span><br><span class="line">        <span class="comment">// 窗口-cnt[nums[l]]&gt;k 淘汰</span></span><br><span class="line">        <span class="keyword">while</span> (r - l + <span class="number">1</span> - cnt[nums[l]] &gt; k) &#123;</span><br><span class="line">            cnt[nums[l++]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = fmax(ans, cnt[nums[r]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2271-毯子覆盖的最多砖块数目"><a href="#2271-毯子覆盖的最多砖块数目" class="headerlink" title="2271 毯子覆盖的最多砖块数目"></a>2271 毯子覆盖的最多砖块数目</h2><ul>
<li>给你一个二维整数数组 tiles ，其中 tiles[i] &#x3D; [li, ri] ，表示所有在 li &lt;&#x3D; j &lt;&#x3D; ri 之间的每个瓷砖位置 j 都被涂成了白色。同时给你一个整数 carpetLen ，表示可以放在 任何位置 的一块毯子的长度。请你返回使用这块毯子，最多 可以盖住多少块瓷砖。</li>
<li>思路：<br>将 tiles 按左端点排序后，我们可以枚举毯子的摆放位置，然后计算毯子能覆盖多少块瓷砖。实际上，毯子右端点放在一段瓷砖中间，是不如直接放在这段瓷砖右端点的（因为从中间向右移动，能覆盖的瓷砖数不会减少），所以可以枚举每段瓷砖的右端点来摆放毯子的右端点。这样就可以双指针了，左指针 left 需要满足其指向的那段瓷砖的右端点被毯子覆盖。设毯子右端点在瓷砖段 i 上，则毯子左端点位于 <code>tiles[i][1]−carpetLen+1</code>对于 left 需要满足<code>tiles[left][1]≥tiles[i][1]−carpetLen+1</code>。如果毯子左端点在瓷砖段 tiles[left] 内部，则覆盖的瓷砖数还需要额外减去这段瓷砖没被覆盖的部分，即减去<code>(tiles[i][1]−carpetLen+1)−tiles[left][0]</code>如果上式是负数则不减。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumWhiteTiles</span><span class="params">(<span class="type">int</span>[][] tiles, <span class="type">int</span> carpetLen)</span> &#123;</span><br><span class="line">        Arrays.sort(tiles, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] tile : tiles) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tl</span> <span class="operator">=</span> tile[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">tr</span> <span class="operator">=</span> tile[<span class="number">1</span>];</span><br><span class="line">            cover += tr - tl + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (tiles[left][<span class="number">1</span>] + carpetLen - <span class="number">1</span> &lt; tr) &#123;</span><br><span class="line">                cover -= tiles[left][<span class="number">1</span>] - tiles[left][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">uncover</span> <span class="operator">=</span> Math.max(tr - carpetLen + <span class="number">1</span> - tiles[left][<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">            ans = Math.max(ans, cover - uncover);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="不定长窗口-–-求最短最小"><a href="#不定长窗口-–-求最短最小" class="headerlink" title="不定长窗口 – 求最短最小"></a>不定长窗口 – 求最短最小</h1><h2 id="2875-无限数组的最短子数组"><a href="#2875-无限数组的最短子数组" class="headerlink" title="2875 无限数组的最短子数组"></a>2875 无限数组的最短子数组</h2><ul>
<li>给你一个下标从 0 开始的数组 nums 和一个整数 target 。下标从 0 开始的数组 infinite_nums 是通过无限地将 nums 的元素追加到自己之后生成的。请你从 infinite_nums 中找出满足元素和等于 target 的最短子数组，并返回该子数组的长度。如果不存在满足条件的子数组，返回 -1 。</li>
<li>思路：先取余获取要处理的最小长度，然后是经典的窗口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSizeSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numsSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            numsSum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">initCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (numsSum &lt; target) &#123;</span><br><span class="line">            initCnt = (target / numsSum) * nums.length;</span><br><span class="line">            target = target % numsSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] nnums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                nnums[i * nums.length + j] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(initCnt + &quot; &quot; + target + &quot; &quot; + numsSum);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nnums.length; right++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">in</span> <span class="operator">=</span> nnums[right];</span><br><span class="line">            nowCnt += in;</span><br><span class="line">            <span class="keyword">while</span> (nowCnt &gt; target) &#123;</span><br><span class="line">                nowCnt -= nnums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nowCnt == target) &#123;</span><br><span class="line">                min = Math.min(right - left + <span class="number">1</span>, min);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(left + &quot; &quot; + right + &quot; &quot; + nowCnt);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (min == Integer.MAX_VALUE) ? -<span class="number">1</span> : min + initCnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1234-替换得到平衡子串-统计值是区间外"><a href="#1234-替换得到平衡子串-统计值是区间外" class="headerlink" title="1234 替换得到平衡子串 * 统计值是区间外"></a>1234 替换得到平衡子串 * 统计值是区间外</h2><ul>
<li>有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。假如在该字符串中，这四个字符都恰好出现 n&#x2F;4 次，那么它就是一个「平衡字符串」。给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。请返回待替换子串的最小可能长度。如果原字符串自身就是一个平衡字符串，则返回 0。</li>
<li>思路：根据题意，如果在待替换子串之外的任意字符的出现次数超过 m &#x3D; len&#x2F;4 ，那么无论怎么替换，都无法使这个字符在整个字符串中的出现次数为 m。反过来说，如果在待替换子串之外的任意字符的出现次数都不超过 m，那么可以通过替换，使 s 为平衡字符串，即每个字符的出现次数均为 m。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(String S)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="string">&#x27;X&#x27;</span>]; <span class="comment">// 也可以用哈希表，不过数组更快一些</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt[<span class="string">&#x27;Q&#x27;</span>] == m &amp;&amp; cnt[<span class="string">&#x27;W&#x27;</span>] == m &amp;&amp; cnt[<span class="string">&#x27;E&#x27;</span>] == m &amp;&amp; cnt[<span class="string">&#x27;R&#x27;</span>] == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 已经符合要求啦</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++) &#123; <span class="comment">// 枚举子串右端点</span></span><br><span class="line">            cnt[s[right]]--;</span><br><span class="line">            <span class="keyword">while</span> (cnt[<span class="string">&#x27;Q&#x27;</span>] &lt;= m &amp;&amp; cnt[<span class="string">&#x27;W&#x27;</span>] &lt;= m &amp;&amp; cnt[<span class="string">&#x27;E&#x27;</span>] &lt;= m &amp;&amp; cnt[<span class="string">&#x27;R&#x27;</span>] &lt;= m) &#123;</span><br><span class="line">                ans = Math.min(ans, right - left + <span class="number">1</span>);</span><br><span class="line">                cnt[s[left++]]++; <span class="comment">// 缩小子串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="76-最小覆盖子串-while-满足条件"><a href="#76-最小覆盖子串-while-满足条件" class="headerlink" title="76 最小覆盖子串 * while(满足条件)"></a>76 最小覆盖子串 * while(满足条件)</h2><ul>
<li>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</li>
<li>思路：很典型的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String S, String t)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ansLeft</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ansRight</span> <span class="operator">=</span> m;</span><br><span class="line">        <span class="type">int</span>[] cntS = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>]; <span class="comment">// s 子串字母的出现次数</span></span><br><span class="line">        <span class="type">int</span>[] cntT = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>]; <span class="comment">// t 中字母的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            cntT[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; m; right++) &#123; <span class="comment">// 移动子串右端点</span></span><br><span class="line">            cntS[s[right]]++; <span class="comment">// 右端点字母移入子串</span></span><br><span class="line">            <span class="keyword">while</span> (isCovered(cntS, cntT)) &#123; <span class="comment">// 涵盖</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; ansRight - ansLeft) &#123; <span class="comment">// 找到更短的子串</span></span><br><span class="line">                    ansLeft = left; <span class="comment">// 记录此时的左右端点</span></span><br><span class="line">                    ansRight = right;</span><br><span class="line">                &#125;</span><br><span class="line">                cntS[s[left]]--; <span class="comment">// 左端点字母移出子串</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansLeft &lt; <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : S.substring(ansLeft, ansRight + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCovered</span><span class="params">(<span class="type">int</span>[] cntS, <span class="type">int</span>[] cntT)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cntS[i] &lt; cntT[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cntS[i] &lt; cntT[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="632-最小窗口-巧妙转化为滑动窗口"><a href="#632-最小窗口-巧妙转化为滑动窗口" class="headerlink" title="632 最小窗口 * 巧妙转化为滑动窗口"></a>632 最小窗口 * 巧妙转化为滑动窗口</h2><ul>
<li>你有 k 个 非递减排列 的整数列表。找到一个 最小 区间，使得 k 个列表中的每个列表至少有一个数包含在其中。我们定义如果 b-a &lt; d-c 或者在 b-a &#x3D;&#x3D; d-c 时 a &lt; c，则区间 [a,b] 比 [c,d] 小。</li>
<li>思路：<img src="/2025/02/27/LeetCode%E5%88%B7%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/image.png" alt="alt text"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : nums) &#123;</span><br><span class="line">            sumLen += list.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] pairs = <span class="keyword">new</span> <span class="title class_">int</span>[sumLen][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : nums.get(i)) &#123;</span><br><span class="line">                pairs[pi][<span class="number">0</span>] = x;</span><br><span class="line">                pairs[pi++][<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(pairs, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ansL</span> <span class="operator">=</span> pairs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ansR</span> <span class="operator">=</span> pairs[sumLen - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">empty</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[empty];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p : pairs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> p[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) &#123; <span class="comment">// 包含 nums[i] 的数字</span></span><br><span class="line">                empty--;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[i]++;</span><br><span class="line">            <span class="keyword">while</span> (empty == <span class="number">0</span>) &#123; <span class="comment">// 每个列表都至少包含一个数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> pairs[left][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (r - l &lt; ansR - ansL) &#123;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                    ansR = r;</span><br><span class="line">                &#125;</span><br><span class="line">                i = pairs[left][<span class="number">1</span>];</span><br><span class="line">                cnt[i]--;</span><br><span class="line">                <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) &#123; <span class="comment">// 不包含 nums[i] 的数字</span></span><br><span class="line">                    empty++;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ansL, ansR&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="不定长窗口-–-求子数组个数-–-越长越合"><a href="#不定长窗口-–-求子数组个数-–-越长越合" class="headerlink" title="不定长窗口 – 求子数组个数 – 越长越合"></a>不定长窗口 – 求子数组个数 – 越长越合</h1><ul>
<li>while(满足条件) 统计当前满足个数加到历史满足个数，历史满足的未来还能满足。关键在判断对于满足的窗口，窗口如果继续扩大，是否还能保证满足</li>
</ul>
<h2 id="1358-包含所有三种字符的子字符串数目-经典子数组：更长的子数组能继续满足降低复杂度到O-n"><a href="#1358-包含所有三种字符的子字符串数目-经典子数组：更长的子数组能继续满足降低复杂度到O-n" class="headerlink" title="1358 包含所有三种字符的子字符串数目 * 经典子数组：更长的子数组能继续满足降低复杂度到O(n)"></a>1358 包含所有三种字符的子字符串数目 * 经典子数组：更长的子数组能继续满足降低复杂度到O(n)</h2><ul>
<li>给你一个字符串 s ，它只包含三种字符 a, b 和 c 。请你返回 a，b 和 c 都 至少 出现过一次的子字符串数目。</li>
<li>思路：关键是res +&#x3D; left;因为每次右指针移动时每个以前的子字符串都在变长，以前能满足的肯定还是可以满足。也就是left++代表从left到当前right位置已经满足，所有如果right继续右移，也能满足<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowRightCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; cs.length; right++) &#123;</span><br><span class="line">            cnt[cs[right] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">while</span> (cnt[<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cnt[cs[left] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2799-统计完全子数组数目"><a href="#2799-统计完全子数组数目" class="headerlink" title="2799 统计完全子数组数目"></a>2799 统计完全子数组数目</h2><ul>
<li>给你一个由 正 整数组成的数组 nums 。如果数组中的某个子数组满足下述条件，则称之为 完全子数组 ：子数组中 不同 元素的数目等于整个数组不同元素的数目。返回数组中 完全子数组 的数目。子数组 是数组中的一个连续非空序列。</li>
<li>思路：窗口内是整个数组内不同元素，不会有新元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countCompleteSubarrays</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> set.size();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (map.size() == len) &#123;</span><br><span class="line">                map.put(nums[left], map.get(nums[left]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(nums[left]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(nums[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关键是这里为什么可以是+=left</span></span><br><span class="line">            <span class="comment">// 窗口内是整个数组不同的元素，不会有新元素！！</span></span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2537-统计好子数组的个数"><a href="#2537-统计好子数组的个数" class="headerlink" title="2537 统计好子数组的个数"></a>2537 统计好子数组的个数</h2><ul>
<li>给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中 好 子数组的数目。一个子数组 arr 如果有 至少 k 对下标 (i, j) 满足 i &lt; j 且 arr[i] &#x3D;&#x3D; arr[j] ，那么称它是一个好子数组。子数组 是原数组中一段连续非空的元素序列。</li>
<li>思路：还是经典思路，left - right满足，对于后续right继续增加显然也满足<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countGood</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 至少k组相同元素</span></span><br><span class="line">        <span class="comment">// 如果是3个相同 = 3对</span></span><br><span class="line">        <span class="comment">// 4个 = 1 1 1 1 = 3 + 2 + 1 = 6</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cnt.put(nums[i], cnt.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (cnt.get(nums[i]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                nowCnt += (cnt.get(nums[i]) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (nowCnt &gt;= k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> nums[left];</span><br><span class="line">                <span class="keyword">if</span> (cnt.get(leftNum) == <span class="number">1</span>)  &#123;</span><br><span class="line">                    cnt.remove(leftNum);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nowCnt -= (cnt.get(leftNum) - <span class="number">1</span>);</span><br><span class="line">                    cnt.put(leftNum, cnt.get(leftNum) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3298-重新排列后包含另一个字符串的子字符串个数"><a href="#3298-重新排列后包含另一个字符串的子字符串个数" class="headerlink" title="3298 重新排列后包含另一个字符串的子字符串个数"></a>3298 重新排列后包含另一个字符串的子字符串个数</h2><ul>
<li>给你两个字符串 word1 和 word2 。如果一个字符串 x 重新排列后，word2 是重排字符串的 前缀 ，那么我们称字符串 x 是 合法的 。请你返回 word1 中 合法 子字符串 的数目。注意 ，这个问题中的内存限制比其他题目要 小 ，所以你 必须 实现一个线性复杂度的解法</li>
<li>思路：还是经典思路，记录差值数组比记录个数数组时间上好一些<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录差值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">validSubstringCount</span><span class="params">(String S, String T)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.length() &lt; T.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] t = T.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>]; <span class="comment">// t 的字母出现次数与 s 的字母出现次数之差</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">            diff[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计窗口内有多少个字母的出现次数比 t 的少</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d : diff) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                less++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            diff[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (diff[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// c 移入窗口后，窗口内 c 的出现次数和 t 的一样</span></span><br><span class="line">                less--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less == <span class="number">0</span>) &#123; <span class="comment">// 窗口符合要求</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">outChar</span> <span class="operator">=</span> s[left++]; <span class="comment">// 准备移出窗口的字母</span></span><br><span class="line">                <span class="keyword">if</span> (diff[outChar - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// outChar 移出窗口之前检查出现次数，</span></span><br><span class="line">                    <span class="comment">// 如果窗口内 outChar 的出现次数和 t 的一样，</span></span><br><span class="line">                    <span class="comment">// 那么 outChar 移出窗口后，窗口内 outChar 的出现次数比 t 的少</span></span><br><span class="line">                    less++;</span><br><span class="line">                &#125;</span><br><span class="line">                diff[outChar - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录个数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">validSubstringCount</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 子字符串满足出现元素个数&gt;=word2</span></span><br><span class="line">        <span class="type">int</span>[] cnt1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] cnt2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] cs1 = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] cs2 = word2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : cs2) &#123;</span><br><span class="line">            cnt2[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cs1.length; i++) &#123;</span><br><span class="line">            cnt1[cs1[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">while</span> (check(cnt1, cnt2) &amp;&amp; left &lt;= i) &#123;</span><br><span class="line">                <span class="comment">//System.out.println(Arrays.toString(cnt1) + &quot; &quot; + left);</span></span><br><span class="line">                cnt1[cs1[left] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] c1, <span class="type">int</span>[] c2)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c1[i] &lt; c2[i] &amp;&amp; c2[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="不定长窗口-–-求子数组个数-–-越短越合"><a href="#不定长窗口-–-求子数组个数-–-越短越合" class="headerlink" title="不定长窗口 – 求子数组个数 – 越短越合"></a>不定长窗口 – 求子数组个数 – 越短越合</h1><ul>
<li>while(满足条件) 内层循环结束后，left – right的子数组都是能满足目标的，也就是说当前是最大的满足窗口，相对来说好理解</li>
</ul>
<h2 id="2762-不间断子数组"><a href="#2762-不间断子数组" class="headerlink" title="2762 不间断子数组"></a>2762 不间断子数组</h2><ul>
<li>给你一个下标从 0 开始的整数数组 nums 。nums 的一个子数组如果满足以下条件，那么它是 不间断 的：i，i + 1 ，…，j  表示子数组中的下标。对于所有满足 i &lt;&#x3D; i1, i2 &lt;&#x3D; j 的下标对，都有 0 &lt;&#x3D; |nums[i1] - nums[i2]| &lt;&#x3D; 2 。请你返回 不间断 子数组的总数目。子数组是一个数组中一段连续 非空 的元素序列。</li>
<li>思路：在窗口移动过程中还要维护最大值和最小值，可以利用数据结构<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">continuousSubarrays</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            t.merge(nums[right], <span class="number">1</span>, Integer::sum);</span><br><span class="line">            <span class="keyword">while</span> (t.lastKey() - t.firstKey() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> nums[left++];</span><br><span class="line">                <span class="keyword">if</span> (t.get(y) == <span class="number">1</span>) t.remove(y);</span><br><span class="line">                <span class="keyword">else</span> t.merge(y, -<span class="number">1</span>, Integer::sum);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += right - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/27/LeetCode%E5%88%B7%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" data-id="cm7qdvwzg0007jsvc0ozzad98" data-title="LeetCode刷题-滑动窗口" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/02/27/LeetCodeHot100/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          LeetCodeHot100
        
      </div>
    </a>
  
  
    <a href="/2024/12/23/Debian%E5%8C%85%E6%9E%84%E5%BB%BA/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Debian包构建</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LCR119/">LCR119</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/">LeetCode101</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E5%9B%9E%E6%BA%AF/">回溯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">深度优先搜索</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode%E5%88%B7%E9%A2%98/">LeetCode刷题</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode%E5%88%B7%E9%A2%98/Hot100/">Hot100</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode%E5%88%B7%E9%A2%98/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Makefile/">Makefile</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/REDIS/">REDIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/">Dubbo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Kafka/">Kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/MIT-6824/">MIT-6824</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RabbitMQ/">RabbitMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RocketMQ/">RocketMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/TypeScript/">TypeScript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/">baosight</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/OPC-UA/">OPC_UA</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA/">开源社区</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/">网络系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/">日常开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/ImageMatchingfromHandcraftedtoDeepFeatures-ASurvey/">ImageMatchingfromHandcraftedtoDeepFeatures:ASurvey</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/">分治</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">常用算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">软件设计</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/%E6%8F%8F%E8%BF%B0%E4%B8%8E%E9%9D%A2%E8%AF%95/">描述与面试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/%E6%AF%95%E8%AE%BE/">毕设</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/06/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0/">JAVA线程池</a>
          </li>
        
          <li>
            <a href="/2025/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A8%A1%E7%89%88/">设计模式模版</a>
          </li>
        
          <li>
            <a href="/2025/03/03/%E6%AF%95%E8%AE%BE-%E5%90%8E%E7%AB%AF%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/">毕设-后端与核心算法</a>
          </li>
        
          <li>
            <a href="/2025/03/02/Mysql-%E9%94%81%E6%9C%BA%E5%88%B6/">Mysql-锁机制</a>
          </li>
        
          <li>
            <a href="/2025/03/02/Maven/">Maven</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>