<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/28/JVM/" class="article-date">
  <time class="dt-published" datetime="2024-10-28T15:39:22.000Z" itemprop="datePublished">2024-10-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/28/JVM/">JVM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JAVA与C-之间有一堵由内存动态分配和GC所围成的高墙，墙外面的人想进去，墙里面的人想出来"><a href="#JAVA与C-之间有一堵由内存动态分配和GC所围成的高墙，墙外面的人想进去，墙里面的人想出来" class="headerlink" title="JAVA与C++之间有一堵由内存动态分配和GC所围成的高墙，墙外面的人想进去，墙里面的人想出来"></a>JAVA与C++之间有一堵由内存动态分配和GC所围成的高墙，墙外面的人想进去，墙里面的人想出来</h1><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul>
<li>JAVA虚拟机管理的内存包括以下几个运行时数据区域：<ol>
<li>方法区</li>
<li>堆</li>
<li>虚拟机栈</li>
<li>程序计数器：当前线程所执行的字节码的行号指示器，是程序控制流的指示器。</li>
<li>本地方法栈</li>
</ol>
</li>
<li>程序计数器：由于JAVA虚拟机的多线程是通过线程轮流切换，分配处理器时间实现的，在任何一个时刻只会有一条线程中的指令被执行，因此每个线程要有一个独立的程序计数器（在线程私有的内存区域中存储）。如果执行的是Native方法（在Java中，native方法是一种特殊的方法，它允许Java调用非Java代码，通常是C或C++语言编写的本地方法。这些方法在Java类中声明，但不在Java代码中实现，而是在本地库中实现，并通过Java Native Interface（JNI）与Java代码交互。），那么计数器值应该为空，此内存区域没有规定OutOfMeomoryError错误、</li>
<li>Java虚拟机栈：同样是线程私有的，描述的是Java方法执行的线程内存模型：每个方法被执行时，Java虚拟机栈会同步创建一个栈帧用于存储局部变量表（基础数据类型，对象引用），操作数栈，动态连接，方法出口等信息。数据类型在局部变量表中的存储以局部变量槽（Slot）表示。</li>
<li>本地方法栈：和Java虚拟机栈类似，但是是为Native方法服务的，前者是为Java方法服务的。</li>
<li>Java堆：<strong>所有线程共享</strong>。由垃圾收集器（几乎都基于分代设计，需要新老代收集器搭配工作）管理。从内存分配的角度上，可以分配出线程私有的分配缓冲区。Java堆可以在物理上不连续的内存空间中，但是逻辑上应该被看做连续的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/28/JVM/" data-id="cm2t8girt0000gcvcfgoihoiy" data-title="JVM" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JAVA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/26/JAVA/" class="article-date">
  <time class="dt-published" datetime="2024-10-26T10:16:50.000Z" itemprop="datePublished">2024-10-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/26/JAVA/">JAVA</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>当对象被序列化时，被该对象持有的实例变量也会被序列化，所有被引用的对象也会被实例化，这些操作都是自动进行的</p>
<ul>
<li>要让类能被序列化，要实现Serializable接口</li>
<li>如果要让实例变量不被序列化，<strong>用transient关键字修饰</strong></li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/26/JAVA/" data-id="cm2t8fzex0000dgvcha00cv3s" data-title="JAVA" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux常用命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2024-10-24T09:22:47.000Z" itemprop="datePublished">2024-10-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Linux常用命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><ul>
<li>-A ：所有的进程均显示出来，与 -e 具有同样的效用；</li>
<li>-a ： 显示现行终端机下的所有进程，包括其他用户的进程；</li>
<li>-u ：以用户为主的进程状态 ；</li>
<li>-x ：通常与 a 这个参数一起使用，可列出较完整信息。</li>
<li>-l ：较长、较详细的将该PID 的的信息列出；</li>
<li>-j ：工作的格式 (jobs format)</li>
<li>-f ：做一个更为完整的输出</li>
<li><img src="/2024/10/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/ps.png"></li>
<li>通过<code>ps aux | grep name</code>查询特定名字进程的相关信息</li>
</ul>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><ul>
<li>top的使用方式 top [-d number] | top [-bnp]<ul>
<li>-d number	number代表秒数，表示top命令显示的页面更新一次的间隔 (default&#x3D;5s)</li>
<li>-b	以批次的方式执行top</li>
<li>-n	与-b配合使用，表示需要进行几次top命令的输出结果</li>
<li>-p	指定特定的pid进程号进行观察</li>
</ul>
</li>
<li><img src="/2024/10/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/top.png"></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="cm2t8fzf80002dgvc53cqcmi5" data-title="Linux常用命令" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-开发技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/23/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2024-10-23T02:58:46.000Z" itemprop="datePublished">2024-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/">日常开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/23/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/">开发技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="快速格式化代码"><a href="#快速格式化代码" class="headerlink" title="快速格式化代码"></a>快速格式化代码</h2><ul>
<li>Windows &#x2F; Linux: Shift + Alt + F</li>
<li>macOS: Shift + Option + F</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>在函数上方输入 &#x2F;**，然后按下 Enter，VS Code 会自动生成基本的注释结构。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/23/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" data-id="cm2t8fzfd0006dgvchm5h1q02" data-title="开发技巧" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="opcua-OPCUA-open62541加密原理" class="h-entry article article-type-opcua" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/23/OPCUA-open62541%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2024-10-23T02:48:45.000Z" itemprop="datePublished">2024-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>►<a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/">baosight</a>►<a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/OPC-UA/">OPC_UA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/23/OPCUA-open62541%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/">OPUCA open62541加密原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="加密通信相关代码"><a href="#加密通信相关代码" class="headerlink" title="加密通信相关代码"></a>加密通信相关代码</h2><h3 id="securityPolicy"><a href="#securityPolicy" class="headerlink" title="securityPolicy"></a>securityPolicy</h3><p>+ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UA_SecurityPolicy</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Additional data */</span></span><br><span class="line">    <span class="type">void</span> *policyContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The policy uri that identifies the implemented algorithms */</span></span><br><span class="line">    UA_String policyUri;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Value indicating the crypto strength of the policy, with zero for deprecated or none */</span></span><br><span class="line">    UA_Byte securityLevel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The local certificate is specific for each SecurityPolicy since it</span></span><br><span class="line"><span class="comment">     * depends on the used key length. */</span></span><br><span class="line">    UA_ByteString localCertificate;</span><br><span class="line"></span><br><span class="line">    UA_NodeId certificateGroupId;</span><br><span class="line">    UA_NodeId certificateTypeId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function pointers grouped into modules */</span></span><br><span class="line">    UA_SecurityPolicyAsymmetricModule asymmetricModule; <span class="comment">// 包括证书指纹生成算法，加密算法，签名算法等等</span></span><br><span class="line">    UA_SecurityPolicySymmetricModule symmetricModule;</span><br><span class="line">    UA_SecurityPolicySignatureAlgorithm certificateSigningAlgorithm;</span><br><span class="line">    UA_SecurityPolicyChannelModule channelModule;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> UA_Logger *logger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Updates the ApplicationInstanceCertificate and the corresponding private</span></span><br><span class="line"><span class="comment">     * key at runtime. */</span></span><br><span class="line">    UA_StatusCode (*updateCertificateAndPrivateKey)(UA_SecurityPolicy *policy,</span><br><span class="line">                                                    <span class="type">const</span> UA_ByteString newCertificate,</span><br><span class="line">                                                    <span class="type">const</span> UA_ByteString newPrivateKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Creates a PKCS #10 DER encoded certificate request signed with the server&#x27;s</span></span><br><span class="line"><span class="comment">     * private key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param securityPolicy The securityPolicy to work on.</span></span><br><span class="line"><span class="comment">     * @param subjectName The subject name to use in the Certificate Request.</span></span><br><span class="line"><span class="comment">     *                    If not specified the SubjectName from the current Certificate is used.</span></span><br><span class="line"><span class="comment">     * @param nonce Additional entropy that the caller can provide.</span></span><br><span class="line"><span class="comment">     *              It shall be at least 32 bytes long.</span></span><br><span class="line"><span class="comment">     * @param params A KeyVaue list that can be used for additional parameters later.</span></span><br><span class="line"><span class="comment">     * @param csr Returns the created CSR. If the passed byte string is not empty, nothing is created.</span></span><br><span class="line"><span class="comment">     * @param newPrivateKey Returns the private key if a new one needs to be generated.</span></span><br><span class="line"><span class="comment">     *                      Alternatively, an existing key can be provided,</span></span><br><span class="line"><span class="comment">     *                      which will be used as the CSR key in the security policy.</span></span><br><span class="line"><span class="comment">     *                      This is necessary if the CSR was created under a different security policy</span></span><br><span class="line"><span class="comment">     *                      and the current one only requires an update.</span></span><br><span class="line"><span class="comment">     * @return If the CSR creation was successful, UA_STATUSCODE_GOOD is returned. */</span></span><br><span class="line">    UA_StatusCode (*createSigningRequest)(UA_SecurityPolicy *securityPolicy,</span><br><span class="line">                                          <span class="type">const</span> UA_String *subjectName,</span><br><span class="line">                                          <span class="type">const</span> UA_ByteString *nonce,</span><br><span class="line">                                          <span class="type">const</span> UA_KeyValueMap *params,</span><br><span class="line">                                          UA_ByteString *csr,</span><br><span class="line">                                          UA_ByteString *newPrivateKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Deletes the dynamic content of the policy */</span></span><br><span class="line">    <span class="type">void</span> (*clear)(UA_SecurityPolicy *policy);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="安全令牌轮换"><a href="#安全令牌轮换" class="headerlink" title="安全令牌轮换"></a>安全令牌轮换</h3><p>续订安全令牌的目的是在安全通信通道（如加密会话）中定期更换令牌，以增强安全性并防止重放攻击。</p>
<p>+ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Rules for revolving the token with a renew OPN request: The client is</span></span><br><span class="line"><span class="comment"> * allowed to accept messages with the old token until the OPN response has</span></span><br><span class="line"><span class="comment"> * arrived. The server accepts the old token until one message secured with</span></span><br><span class="line"><span class="comment"> * the new token has arrived.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We recognize whether nextSecurityToken contains a valid next token if the</span></span><br><span class="line"><span class="comment"> * ChannelId is not 0. */</span></span><br><span class="line">UA_ChannelSecurityToken securityToken;    <span class="comment">/* Also contains the channelId */</span></span><br><span class="line">UA_ChannelSecurityToken altSecurityToken; <span class="comment">/* Alternative token for the rollover.</span></span><br><span class="line"><span class="comment">                                           * See the renewState. */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>令牌轮换的规则<ol>
<li>客户端规则: 当客户端发送带有续订的 OpenSecureChannelRequest (OPN) 请求时，客户端可以继续使用旧的安全令牌，直到服务器返回的 OPN 响应到达为止。这意味着客户端在这个过程中还可以接受用旧令牌加密的消息。</li>
<li>服务器规则: 服务器则允许使用旧的安全令牌，直到它收到客户端用新的安全令牌加密的消息为止。即，服务器知道客户端已经开始使用新令牌。</li>
</ol>
</li>
<li>如何识别下一个安全令牌是否有效<br>下一个安全令牌的有效性可以通过检查 nextSecurityToken 中的 ChannelId 字段来确认。如果 ChannelId 不为 0，表示下一个安全令牌有效。ChannelId 是标识通信信道的唯一标识符，通常它在有效的通信会话中是非零的。</li>
<li>renewState是一个状态机，用于跟踪续订请求的状态，以确保安全令牌的顺利轮换。</li>
</ul>
<h3 id="padding（-c文件内搜索add-padding）"><a href="#padding（-c文件内搜索add-padding）" class="headerlink" title="padding（.c文件内搜索add padding）"></a>padding（.c文件内搜索add padding）</h3><p>+<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Assumes that pos can be advanced to the end of the current block */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">padChunk</span><span class="params">(UA_SecureChannel *channel, <span class="type">const</span> UA_SecurityPolicyCryptoModule *cm,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> UA_Byte *start, UA_Byte **pos)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> bytesToWrite = (<span class="type">uintptr_t</span>)*pos - (<span class="type">uintptr_t</span>)start;</span><br><span class="line">    <span class="type">size_t</span> signatureSize = cm-&gt;signatureAlgorithm.</span><br><span class="line">        getLocalSignatureSize(channel-&gt;channelContext);</span><br><span class="line">    <span class="type">size_t</span> plainTextBlockSize = cm-&gt;encryptionAlgorithm.</span><br><span class="line">        getRemotePlainTextBlockSize(channel-&gt;channelContext);</span><br><span class="line">    UA_Boolean extraPadding = (cm-&gt;encryptionAlgorithm.</span><br><span class="line">        getRemoteKeyLength(channel-&gt;channelContext) &gt; <span class="number">2048</span>);</span><br><span class="line">    <span class="type">size_t</span> paddingBytes = (UA_LIKELY(!extraPadding)) ? <span class="number">1u</span> : <span class="number">2u</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> lastBlock = ((bytesToWrite + signatureSize + paddingBytes) % plainTextBlockSize);</span><br><span class="line">    <span class="type">size_t</span> paddingLength = (lastBlock != <span class="number">0</span>) ? plainTextBlockSize - lastBlock : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    UA_LOG_TRACE_CHANNEL(channel-&gt;securityPolicy-&gt;logger, channel,</span><br><span class="line">                        <span class="string">&quot;Add %lu bytes of padding plus %lu padding size bytes&quot;</span>,</span><br><span class="line">                        (<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)paddingLength,</span><br><span class="line">                        (<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)paddingBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the padding. This is &lt;= because the paddingSize byte also has to be</span></span><br><span class="line"><span class="comment">    * written */</span></span><br><span class="line">    UA_Byte paddingByte = (UA_Byte)paddingLength;</span><br><span class="line">    <span class="keyword">for</span>(UA_UInt16 i = <span class="number">0</span>; i &lt;= paddingLength; ++i) &#123;</span><br><span class="line">        **pos = paddingByte;</span><br><span class="line">        ++*pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the extra padding byte if required */</span></span><br><span class="line">    <span class="keyword">if</span>(extraPadding) &#123;</span><br><span class="line">        **pos = (UA_Byte)(paddingLength &gt;&gt; <span class="number">8u</span>);</span><br><span class="line">        ++*pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    + UA_SecureChannel是安全通道的上下文类，包括channel状态，连接配置，安全模式等channel的信息，以及绑定到这个channel上的session，接收到的message chunk等信息</p>
<h3 id="sign-encrypt"><a href="#sign-encrypt" class="headerlink" title="sign &amp; encrypt"></a>sign &amp; encrypt</h3><h4 id="asym"><a href="#asym" class="headerlink" title="asym"></a>asym</h4><p>+ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">UA_StatusCode</span><br><span class="line"><span class="title function_">signAndEncryptAsym</span><span class="params">(UA_SecureChannel *channel, <span class="type">size_t</span> preSignLength,</span></span><br><span class="line"><span class="params">                   UA_ByteString *buf, <span class="type">size_t</span> securityHeaderLength,</span></span><br><span class="line"><span class="params">                   <span class="type">size_t</span> totalLength)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(channel-&gt;securityMode != UA_MESSAGESECURITYMODE_SIGN &amp;&amp;</span><br><span class="line">       channel-&gt;securityMode != UA_MESSAGESECURITYMODE_SIGNANDENCRYPT)</span><br><span class="line">        <span class="keyword">return</span> UA_STATUSCODE_GOOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sign message */</span></span><br><span class="line">    <span class="type">const</span> UA_SecurityPolicy *sp = channel-&gt;securityPolicy;</span><br><span class="line">    <span class="type">const</span> UA_ByteString dataToSign = &#123;preSignLength, buf-&gt;data&#125;;</span><br><span class="line">    <span class="type">size_t</span> sigsize = sp-&gt;asymmetricModule.cryptoModule.signatureAlgorithm.</span><br><span class="line">        getLocalSignatureSize(channel-&gt;channelContext);</span><br><span class="line">    UA_ByteString signature = &#123;sigsize, buf-&gt;data + preSignLength&#125;;</span><br><span class="line">    UA_StatusCode retval = sp-&gt;asymmetricModule.cryptoModule.signatureAlgorithm.</span><br><span class="line">        sign(channel-&gt;channelContext, &amp;dataToSign, &amp;signature);</span><br><span class="line">    UA_CHECK_STATUS(retval, <span class="keyword">return</span> retval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Specification part 6, 6.7.4: The OpenSecureChannel Messages are</span></span><br><span class="line"><span class="comment">     * signed and encrypted if the SecurityMode is not None (even if the</span></span><br><span class="line"><span class="comment">     * SecurityMode is SignOnly). */</span></span><br><span class="line">    <span class="type">size_t</span> unencrypted_length =</span><br><span class="line">        UA_SECURECHANNEL_CHANNELHEADER_LENGTH + securityHeaderLength;</span><br><span class="line">    UA_ByteString dataToEncrypt = &#123;totalLength - unencrypted_length,</span><br><span class="line">                                   &amp;buf-&gt;data[unencrypted_length]&#125;;</span><br><span class="line">    <span class="keyword">return</span> sp-&gt;asymmetricModule.cryptoModule.encryptionAlgorithm.</span><br><span class="line">        encrypt(channel-&gt;channelContext, &amp;dataToEncrypt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/23/OPCUA-open62541%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/" data-id="cm2la0nwc000534vcbazx92x8" data-title="OPUCA open62541加密原理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MVC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/22/MVC/" class="article-date">
  <time class="dt-published" datetime="2024-10-22T07:48:38.000Z" itemprop="datePublished">2024-10-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E6%A0%88/">分布式技术栈</a>►<a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E6%A0%88/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/22/MVC/">MVC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="传统的MVC结构："><a href="#传统的MVC结构：" class="headerlink" title="传统的MVC结构："></a>传统的MVC结构：</h2><ul>
<li><p>分层</p>
<ol>
<li>M - model 对象层，封装到 domain 里。</li>
<li>V - view 展示层，但因为目前都是前后端分离的项目，几乎不会在后端项目里写 JSP 文件了。</li>
<li>C - Controller 控制层，对外提供接口实现类。HTTP接口</li>
<li>DAO 算是单独拿出来用户处理数据库操作的层。</li>
<li>Service：功能方法，服务层逻辑的实现</li>
</ol>
</li>
<li><p>调用流程：<br><img src="/2024/10/22/MVC/MVC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/22/MVC/" data-id="cm2la0nvz000034vchv9s9f78" data-title="MVC" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IO多路复用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/21/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2024-10-21T08:47:21.000Z" itemprop="datePublished">2024-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/21/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">IO多路复用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><ul>
<li>复用IO的基本思路就是通过slect或poll、epoll 来监控多fd ，来达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的。当发现某个描述符就绪之后，能够通知程序进行相应的读写操作。</li>
</ul>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul>
<li><code>int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout);</code></li>
<li>运行机制：我们上面提到过，传入的参数有一个 fd_set 集合，其实这是一个 long 类型的数组，数组元素能够与已经打开的文件句柄（例如 Socket 句柄，又或者其它文件）建立联系。当我们调用 select 函数时，内核会根据 IO 状态对 fd_set 的内容进行修改，从而通知执行 select 函数的进程哪一个文件或者 Socket 是可读的。select 函数与同步阻塞模型并无过多区别，甚至还多出了一部分操作（监视 socket &#x2F;调用 select 函数），导致更低的效率。</li>
<li>优势：用户可以在一个线程内同时处理多个 socket 的 IO 请求。用户可以注册多个 socket，然后调用 select 函数读取被激活的 socket，从而实现在同一个线程内同时处理多个 IO 请求，在这点上select 函数与同步阻塞模型不同，因为在同步阻塞模型中需要通过多线程才能达到这个目的。话说回来，为啥我们不直接使用多进程&#x2F;多线程技术，而是要使用 IO 多路复用技术呢?这是因为，使用 IO 多路复用技术，系统不必创建和维护进程&#x2F;线程，从而节约了系统的开销。</li>
<li>缺点：<ol>
<li>调用 select 函数时，需要把 fd_set 集合从用户态拷贝到内核态，当 fd_set 集合很大时，这个开销将会非常巨大，且需要在内核遍历传递进来的所有 fd_set，当 fd_set 集合很大时，这个开销将会非常巨大。</li>
<li>fd_set集合大小有限制</li>
</ol>
</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul>
<li><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code></li>
<li>运行机制：select 函数中，内核对 fd_set 集合的大小做出了限制，大小不可变为1024；而 poll 函数中，并没有最大文件描述符数量的限制（基于链表存储）。其余和select没有区别</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>+ </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>epoll_create：创建一个 epoll 句柄，其中 size 表示内核要监听的描述符数量</li>
<li>epoll_ctl：注册要监听的事件类型。在每次注册新的事件到 epoll 句柄中时，会把所有的描述符拷贝进内核，而不是在 epoll_wait 的时候重复拷贝。epoll 保证了每个描述符在整个过程中只会拷贝一次。epoll_ctl函数添加进来的事件都会被放在红黑树的某个节点内</li>
<li>epoll_wait：等待事件的就绪，成功时返回就绪的事件数目<br><img src="/2024/10/21/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/epoll.png"></li>
</ol>
<ul>
<li>epoll 是 poll 的增强版，在获取事件时，epoll 无需遍历整个被监听的描述符集，而是只需遍历被内核 IO 事件异步唤醒而加入 Ready 队列的描述符集合即可。因此，epoll 能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。epoll 会在 epoll_ctl 时为每个描述符指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的描述符加入一个就绪链表。epoll_wait 实际上就是去就绪链表中查看有没有就绪的描述符。</li>
<li>优势：<ol>
<li>没有最大连接数限制</li>
<li>不用轮询所有连接，只需要处理活跃连接</li>
<li>epoll是通过内核与用户空间mmap同一块内存实现的，mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址。减少用户态和内核态之间的数据交换的复制开销。</li>
</ol>
</li>
<li>模式：<ul>
<li>水平触发（LT）：默认工作模式，当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；等到下次调用 epoll_wait 时，会再次通知此事件</li>
<li>边缘触发（ET）：当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次通知此事件</li>
<li>ET 模式减少了 epoll 事件的触发次数，其效率比 LT 模式下高。为什么呢？如果我们使用 LT 模式的话，系统中一旦有大量不需要读写的就绪文件描述符，每次调用 epoll_wait 都会返回，大大降低处理程序检索自己关心的就绪文件描述符的效率。如果使用的是 ET 模式，当被监控的文件描述符上有可读写事件发生时，epoll_wait 会通知处理程序去读写，如果这次没有把数据全部读写完，下次调用 epoll_wait 不会通知你，即它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。在这种模式下，系统不会充斥大量你不关心的就绪文件描述符，故其效率较高。</li>
</ul>
</li>
<li>总结：select，poll 需要自己不断轮询所有描述符集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。epoll 其实也需要调用 epoll_wait 不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪描述符放入就绪链表中，并唤醒在 epoll_wait 中进入睡眠的进程。虽然都要睡眠和交替，但是 select 和 poll 在醒着的时候要遍历整个描述符集合，而epoll在醒着的时候只要判断一下就绪链表是否为空即可，这就是回调机制带来的性能提升，节省了大量的 CPU 时间。</li>
<li>对比：<ol>
<li>IO 效率：select 只知道有 IO 事件发生，却不知道是哪几个流，只能采取轮询所有流的方式，故其具有 O(n) 的无差别轮询复杂度，处理的流越多，无差别轮询时间就越长；poll 与 select 并无区别，它的时间复杂度也是 O(n)；epoll 会将哪个流发生了怎样的 IO 事件通知我们（当描述符就绪时，系统注册的回调函数会被调用，将就绪描述符放到 readyList 里面），它是事件驱动的，其时间复杂度为 O(1)</li>
<li>操作方式：select 和 poll 都是采取遍历的方式，而 epoll 则是采取了回调的方式</li>
<li>底层实现：select 的底层实现为数组，poll 的底层实现为链表，而 epoll 的底层实现为红黑树</li>
<li>最大连接数：select 的最大连接数为 1024 或 2048，而 poll 和 epoll 是无上限的</li>
<li>对描述符的拷贝：select 和 poll 每次被调用时都会把描述符集合从用户态拷贝到内核态，而 epoll 在调用 epoll_ctl 时会拷贝进内核并保存，之后每次 epoll_wait 时不会拷贝</li>
<li>性能：epoll 在绝大多数情况下性能远超 select 和 poll，但在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，因为 epoll 的通知机制需要很多函数回调</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/21/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" data-id="cm2irwt2n00002svcdb9obfdt" data-title="IO多路复用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IO模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2024-10-21T07:30:43.000Z" itemprop="datePublished">2024-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/">IO模型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="IO背景"><a href="#IO背景" class="headerlink" title="IO背景"></a>IO背景</h2><ul>
<li>发送一条消息的流程：<ol>
<li>应用A把消息发送到TCP发送缓存区</li>
<li>TCP缓存区发送消息，传递到B服务器的TCP接收缓存区</li>
<li>应用B从TCP接收缓存区读取数据</li>
</ol>
</li>
</ul>
<h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h2><ul>
<li>IO模型：<ol>
<li>阻塞式IO，同步阻塞</li>
<li>非阻塞式IO，同步非阻塞</li>
<li>多路复用IO，同步非阻塞</li>
<li>信号驱动IO，同步非阻塞</li>
<li>异步IO，异步</li>
</ol>
</li>
</ul>
<h3 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h3><ul>
<li>在应用调用recvfrom读取数据时，其系统调用知道数据包到达切被复制到应用缓冲区中或者发送错误时才返回，在此期间一直会等待，进程从调用到返回这段时间内都是被阻塞的成为阻塞IO；</li>
<li><img src="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/image.png"></li>
</ul>
<h3 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h3><ul>
<li>非阻塞IO是在应用调用recvfrom读取数据时，如果该缓冲区没有数据的话，就会直接返回一个EWOULDBLOCK错误，不会让应用一直等待中。在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要不断的调用recvfrom请求，直到读取到它数据要的数据为止。（轮询，中断）</li>
<li>事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</li>
<li><img src="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/image1.png" alt="alt text"></li>
</ul>
<h3 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h3><ul>
<li>背景：如果在并发的环境下，可能会N个人向应用B发送消息，这种情况下我们的应用就必须创建多个线程去读取数据，每个线程都会自己调用recvfrom 去读取数据。并发情况下服务器很可能一瞬间会收到几十上百万的请求，这种情况下应用B就需要创建几十上百万的线程去读取数据，同时又因为应用线程是不知道什么时候会有数据读取，为了保证消息能及时读取到，那么这些线程自己必须不断的向内核发送recvfrom 请求来读取数据，这种方法会占用大量资源。</li>
<li>进程通过将一个或多个fd传递给select（或者其他IO复用API），阻塞在select操作上，select帮我们侦测多个fd是否准备就绪，当有fd准备就绪时，select返回数据可读状态，应用程序再调用recvfrom读取数据。</li>
<li>多路复用IO主要用于处理多个IO连接时候的场景。在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。也许有朋友会说，我可以采用多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</li>
<li><img src="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/image2.png" alt="alt text"></li>
</ul>
<h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><ul>
<li>开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数，此时请求即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知映应用线程调用recvfrom来读取数据。</li>
<li><img src="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/image4.png" alt="alt text"></li>
<li>对比多路复用：IO复用模型里面的select虽然可以监控多个fd了，但select其实现的本质上还是通过不断的轮询fd来监控数据状态， 因为大部分轮询请求其实都是无效的，所以信号驱动IO意在通过这种建立信号关联的方式，实现了发出请求后只需要等待数据就绪的通知即可，这样就可以避免大量无效的数据状态轮询操作。</li>
</ul>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><ul>
<li>不管是IO复用还是信号驱动，我们要读取一个数据总是要发起两阶段的请求，第一次发送select请求，询问数据状态是否准备好，第二次发送recevform请求读取数据。（这也就是为什么上面四种都是同步IO）。如果应用发送完指令后就不再参与过程了，只需要等待最终完成结果的通知，那么这就属于异步。</li>
<li>应用告知内核启动某个操作，并让内核在整个操作完成之后，通知应用，这种模型与信号驱动模型的主要区别在于，信号驱动IO只是由内核通知我们合适可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成。</li>
<li><img src="/2024/10/21/IO%E6%A8%A1%E5%9E%8B/image5.png" alt="alt text"></li>
</ul>
<h3 id="两种高性能IO设计模式：Reactor和Proactor"><a href="#两种高性能IO设计模式：Reactor和Proactor" class="headerlink" title="两种高性能IO设计模式：Reactor和Proactor"></a>两种高性能IO设计模式：Reactor和Proactor</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/21/IO%E6%A8%A1%E5%9E%8B/" data-id="cm2irwt2s00012svc6y761ryd" data-title="IO模型" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数字签名" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" class="article-date">
  <time class="dt-published" datetime="2024-10-17T08:21:47.000Z" itemprop="datePublished">2024-10-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/">数字签名</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数字签名的主要的作用是认证签署人身份，说得具体点，就是让所有人能够确认这个数字签名是不是由私钥的持有人创建的。数字签名是由签名算法去生成的，签名算法的输入有两个，一个是私钥，另一个是被签署的信息（一般是消息的一个摘要），输出的一个字符串就是数字签名了。签名到底是不是由私钥持有人签署的，要通过验证算法判断。验证算法有三个输入，一个是信息本身，另外一个是数字签名，第三个是公钥，输出的结果就是验证成功或者验证失败。数字签名过程中，私钥是“签名 key”，公钥是“验证 key”。</p>
<h2 id="流程原理"><a href="#流程原理" class="headerlink" title="流程原理"></a>流程原理</h2><ol>
<li>用hash函数取出要签名信息的摘要(digest)</li>
<li>用发送方的私钥加密这个摘要</li>
<li>接受方收到信息之后，先用公钥解密摘要，再对原文使用hash函数生成摘要</li>
<li>对比解密摘要和新生成的摘要</li>
</ol>
<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><ol>
<li>为什么可以用私钥加密，公钥解密？<br>A：以一个非对称加密算法为例，加密和解密的过程其实是可逆的，关键在于用什么秘钥加密，希望让什么秘钥能解密</li>
<li>有被伪造的风险吗？公钥就可以解密，摘要是完全暴露的<br>A：这就要依靠hash函数，虽然hash值是暴露的，但是基于hash值伪造一个</li>
</ol>
<h2 id="签名：防止篡改-加密：防止泄密"><a href="#签名：防止篡改-加密：防止泄密" class="headerlink" title="签名：防止篡改 &amp; 加密：防止泄密"></a>签名：防止篡改 &amp; 加密：防止泄密</h2><ul>
<li>同时使用加密和签名？当用公钥加密后，还需要对明文做以下操作（这套算法保证明文改动会使得被私钥签名后的结果改动）：<ol>
<li>用哈希算法抽取明文摘要（非对称算法很耗时，对大量数据加密需要很大算力）</li>
<li>对这个明文摘要用私钥签名</li>
</ol>
</li>
<li>验签时，用私钥得到解密后的明文，用公钥得到解签后的摘要，从明文中抽取摘要对比即可</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/17/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" data-id="cm2ibtc860000c0vc6ry07lpk" data-title="数字签名" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-非对称加密算法原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/17/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2024-10-17T06:59:54.000Z" itemprop="datePublished">2024-10-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/17/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/">非对称加密算法原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/48249182">https://zhuanlan.zhihu.com/p/48249182</a></li>
<li><a target="_blank" rel="noopener" href="https://ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">https://ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></li>
</ol>
<ul>
<li>欧拉定理<br><img src="/2024/10/17/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/%7B297162E5-5F03-4740-A429-7DB33A5DDC51%7D.png"></li>
<li>欧拉函数<br>f(n)是指1-n范围内和n互质的整数的个数</li>
<li>模反函数<br>如果两个正整数a和n互质，那么一定可以找到整数b，使得ab-1被n整除，或者说ab被n除的余数是1。<br>b是a的模反函数</li>
<li>秘钥生成过程</li>
</ul>
<ol>
<li>选择两个不相等质数p，q</li>
<li>计算p * q &#x3D; n，n的长度是秘钥长度，一般1024位即可</li>
<li>计算n的欧拉函数f(n)</li>
<li>随机选一个整数e，满足1 &lt; e &lt; f(n)，且e和f(n)互质，这个值一般就是65537</li>
<li>计算e关于f(n)的模反函数d</li>
<li>ne封装为公钥，nd封装为私钥</li>
</ol>
<ul>
<li>加密&amp;解密</li>
<li>加密就是计算 m^e ≡ c (mod n) (m &lt; n)</li>
<li>解密就是计算 c^d ≡ m (mod n)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/17/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" data-id="cm2d10me300005cvccp61f7oz" data-title="非对称加密算法原理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LCR119/">LCR119</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/">LeetCode101</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E5%9B%9E%E6%BA%AF/">回溯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">深度优先搜索</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Makefile/">Makefile</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/REDIS/">REDIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/MIT-6824/">MIT-6824</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E6%A0%88/">分布式技术栈</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E6%A0%88/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/TypeScript/">TypeScript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/">baosight</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/OPC-UA/">OPC_UA</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/">日常开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/ImageMatchingfromHandcraftedtoDeepFeatures-ASurvey/">ImageMatchingfromHandcraftedtoDeepFeatures:ASurvey</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/">分治</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">常用算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">软件设计</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/10/28/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/2024/10/26/JAVA/">JAVA</a>
          </li>
        
          <li>
            <a href="/2024/10/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Linux常用命令</a>
          </li>
        
          <li>
            <a href="/2024/10/23/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/">开发技巧</a>
          </li>
        
          <li>
            <a href="/2024/10/23/OPCUA-open62541%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/">OPUCA open62541加密原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>