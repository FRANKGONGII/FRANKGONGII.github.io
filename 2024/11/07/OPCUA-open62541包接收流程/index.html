<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>OPCUA open62541-包接收流程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="如果消息太大怎么处理？ 调用流程： sendResponse()：其余处理全部完毕，调用UA_MessageContext_finish(&amp;message_content); UA_MessageContext_finish()：返回sendSymmetricChunk(mc) sendSymmetricChunk()：内部检查adjustCheckMessageLimitsSym(mc,">
<meta property="og:type" content="article">
<meta property="og:title" content="OPCUA open62541-包接收流程">
<meta property="og:url" content="http://example.com/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="如果消息太大怎么处理？ 调用流程： sendResponse()：其余处理全部完毕，调用UA_MessageContext_finish(&amp;message_content); UA_MessageContext_finish()：返回sendSymmetricChunk(mc) sendSymmetricChunk()：内部检查adjustCheckMessageLimitsSym(mc,">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/mOPC_%E5%8C%85%E6%8E%A5%E6%94%B6.png">
<meta property="article:published_time" content="2024-11-07T05:36:05.000Z">
<meta property="article:modified_time" content="2024-11-13T02:08:41.502Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/mOPC_%E5%8C%85%E6%8E%A5%E6%94%B6.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-OPCUA-open62541包接收流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-11-07T05:36:05.000Z" itemprop="datePublished">2024-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a>►<a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/">baosight</a>►<a class="article-category-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/OPC-UA/">OPC_UA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      OPCUA open62541-包接收流程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="如果消息太大怎么处理？"><a href="#如果消息太大怎么处理？" class="headerlink" title="如果消息太大怎么处理？"></a>如果消息太大怎么处理？</h2><ul>
<li>调用流程：<ol>
<li>sendResponse()：其余处理全部完毕，调用UA_MessageContext_finish(&amp;message_content);</li>
<li>UA_MessageContext_finish()：返回sendSymmetricChunk(mc)</li>
<li>sendSymmetricChunk()：内部检查adjustCheckMessageLimitsSym(mc, bodyLength);</li>
<li>adjustCheckMessageLimitsSym()：返回状态码</li>
</ol>
</li>
</ul>
<h2 id="接收包的流程"><a href="#接收包的流程" class="headerlink" title="接收包的流程"></a>接收包的流程</h2><ul>
<li>这个是按目前的理解设计的实现<br><img src="/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/mOPC_%E5%8C%85%E6%8E%A5%E6%94%B6.png"></li>
<li>在包接收 &amp; 处理的流程上，open62541采取的方案是每次把缓冲区存满，提取完整包，保存不完整包下次用</li>
</ul>
<h2 id="接收包的流程-1"><a href="#接收包的流程-1" class="headerlink" title="接收包的流程"></a>接收包的流程</h2><ol>
<li><p>入口函数：UA_SecureChannel_processBuffer：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">UA_StatusCode</span><br><span class="line"><span class="title function_">UA_SecureChannel_processBuffer</span><span class="params">(UA_SecureChannel *channel, <span class="type">void</span> *application,</span></span><br><span class="line"><span class="params">                              UA_ProcessMessageCallback callback,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> UA_ByteString *buffer)</span> &#123;</span><br><span class="line">    <span class="comment">/* Prepend the incomplete last chunk. This is usually done in the</span></span><br><span class="line"><span class="comment">    * networklayer. But we test for a buffered incomplete chunk here again to</span></span><br><span class="line"><span class="comment">    * work around &quot;lazy&quot; network layers. */</span></span><br><span class="line">    <span class="comment">// 先看有没有之前保存的不完整的包，如果有，append到buffer前面</span></span><br><span class="line">    UA_ByteString appended = channel-&gt;incompleteChunk;</span><br><span class="line">    <span class="keyword">if</span>(appended.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        channel-&gt;incompleteChunk = UA_BYTESTRING_NULL;</span><br><span class="line">        UA_Byte *t = (UA_Byte*)UA_realloc(appended.data, appended.length + buffer-&gt;length);</span><br><span class="line">        UA_CHECK_MEM(t, UA_ByteString_clear(&amp;appended);</span><br><span class="line">                    <span class="keyword">return</span> UA_STATUSCODE_BADOUTOFMEMORY);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;t[appended.length], buffer-&gt;data, buffer-&gt;length);</span><br><span class="line">        appended.data = t;</span><br><span class="line">        appended.length += buffer-&gt;length;</span><br><span class="line">        buffer = &amp;appended;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop over the received chunks */</span></span><br><span class="line">    <span class="comment">// 循环，extractCompleteChunk()直到能提取一个完整的包</span></span><br><span class="line">    <span class="type">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    UA_Boolean done = <span class="literal">false</span>;</span><br><span class="line">    UA_StatusCode res;</span><br><span class="line">    <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">        res = extractCompleteChunk(channel, buffer, &amp;offset, &amp;done);</span><br><span class="line">        UA_CHECK_STATUS(res, <span class="keyword">goto</span> cleanup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer half-received chunk. Before processing the messages so that</span></span><br><span class="line"><span class="comment">    * processing is reentrant. */</span></span><br><span class="line">    <span class="comment">// 如果完整包后面还有数据，提取到不完整包</span></span><br><span class="line">    <span class="keyword">if</span>(offset &lt; buffer-&gt;length) &#123;</span><br><span class="line">        res = persistIncompleteChunk(channel, buffer, offset);</span><br><span class="line">        UA_CHECK_STATUS(res, <span class="keyword">goto</span> cleanup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process whatever we can. Chunks of completed and processed messages are</span></span><br><span class="line"><span class="comment">    * removed. */</span></span><br><span class="line">    <span class="comment">// 调用processChunks()处理包</span></span><br><span class="line">    res = processChunks(channel, application, callback);</span><br><span class="line">    UA_CHECK_STATUS(res, <span class="keyword">goto</span> cleanup);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Persist full chunks that still point to the buffer. Can only return</span></span><br><span class="line"><span class="comment">    * UA_STATUSCODE_BADOUTOFMEMORY as an error code. So merging res works. */</span></span><br><span class="line">    res |= persistCompleteChunks(&amp;channel-&gt;completeChunks);</span><br><span class="line">    res |= persistCompleteChunks(&amp;channel-&gt;decryptedChunks);</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    UA_ByteString_clear(&amp;appended);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>提取完整包函数：extractCompleteChunk()</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> UA_StatusCode</span><br><span class="line"><span class="title function_">extractCompleteChunk</span><span class="params">(UA_SecureChannel *channel, <span class="type">const</span> UA_ByteString *buffer,</span></span><br><span class="line"><span class="params">                    <span class="type">size_t</span> *offset, UA_Boolean *done)</span> &#123;</span><br><span class="line">    <span class="comment">/* At least 8 byte needed for the header. Wait for the next chunk. */</span></span><br><span class="line">    <span class="comment">// 判断是否有足够的数据用于提取包</span></span><br><span class="line">    <span class="type">size_t</span> initial_offset = *offset;</span><br><span class="line">    <span class="type">size_t</span> remaining = buffer-&gt;length - initial_offset;</span><br><span class="line">    <span class="keyword">if</span>(remaining &lt; UA_SECURECHANNEL_MESSAGEHEADER_LENGTH) &#123;</span><br><span class="line">        *done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> UA_STATUSCODE_GOOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Decoding cannot fail */</span></span><br><span class="line">    <span class="comment">// 解析消息头，只有MSGType和ChunkType？</span></span><br><span class="line">    UA_TcpMessageHeader hdr;</span><br><span class="line">    UA_StatusCode res =</span><br><span class="line">        UA_decodeBinaryInternal(buffer, &amp;initial_offset, &amp;hdr,</span><br><span class="line">                                &amp;UA_TRANSPORT[UA_TRANSPORT_TCPMESSAGEHEADER], <span class="literal">NULL</span>);</span><br><span class="line">    UA_assert(res == UA_STATUSCODE_GOOD);</span><br><span class="line">    (<span class="type">void</span>)res; <span class="comment">/* pacify compilers if assert is ignored */</span></span><br><span class="line">    UA_MessageType msgType = (UA_MessageType)</span><br><span class="line">        (hdr.messageTypeAndChunkType &amp; UA_BITMASK_MESSAGETYPE);</span><br><span class="line">    UA_ChunkType chunkType = (UA_ChunkType)</span><br><span class="line">        (hdr.messageTypeAndChunkType &amp; UA_BITMASK_CHUNKTYPE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查消息大小是否合法</span></span><br><span class="line">    <span class="keyword">if</span>(hdr.messageSize &lt; UA_SECURECHANNEL_MESSAGE_MIN_LENGTH)</span><br><span class="line">        <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line">    <span class="keyword">if</span>(hdr.messageSize &gt; channel-&gt;config.recvBufferSize)</span><br><span class="line">        <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETOOLARGE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不完整的消息，直接返回等待下一步处理</span></span><br><span class="line">    <span class="keyword">if</span>(hdr.messageSize &gt; remaining) &#123;</span><br><span class="line">        *done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> UA_STATUSCODE_GOOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包的数据</span></span><br><span class="line">    UA_ByteString chunkPayload;</span><br><span class="line">    chunkPayload.data = &amp;buffer-&gt;data[*offset];</span><br><span class="line">    chunkPayload.length = hdr.messageSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有MSG可以有多个包</span></span><br><span class="line">    <span class="keyword">if</span>(msgType == UA_MESSAGETYPE_RHE || msgType == UA_MESSAGETYPE_HEL || msgType == UA_MESSAGETYPE_ACK ||</span><br><span class="line">      msgType == UA_MESSAGETYPE_ERR || msgType == UA_MESSAGETYPE_OPN) &#123;</span><br><span class="line">        <span class="keyword">if</span>(chunkType != UA_CHUNKTYPE_FINAL)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Only messages on SecureChannel-level with symmetric encryption afterwards */</span></span><br><span class="line">        <span class="comment">// 加密相关的检查</span></span><br><span class="line">        <span class="keyword">if</span>(msgType != UA_MESSAGETYPE_MSG &amp;&amp;</span><br><span class="line">          msgType != UA_MESSAGETYPE_CLO)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check the chunk type before decrypting */</span></span><br><span class="line">        <span class="keyword">if</span>(chunkType != UA_CHUNKTYPE_FINAL &amp;&amp;</span><br><span class="line">          chunkType != UA_CHUNKTYPE_INTERMEDIATE &amp;&amp;</span><br><span class="line">          chunkType != UA_CHUNKTYPE_ABORT)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the chunk; forward the offset */</span></span><br><span class="line">    <span class="comment">// 移动处理指针，新建chunk并加入完整队列，注意这时候还没有解析</span></span><br><span class="line">    *offset += hdr.messageSize;</span><br><span class="line">    UA_Chunk *chunk = (UA_Chunk*)UA_malloc(<span class="keyword">sizeof</span>(UA_Chunk));</span><br><span class="line">    UA_CHECK_MEM(chunk, <span class="keyword">return</span> UA_STATUSCODE_BADOUTOFMEMORY);</span><br><span class="line"></span><br><span class="line">    chunk-&gt;bytes = chunkPayload;</span><br><span class="line">    chunk-&gt;messageType = msgType;</span><br><span class="line">    chunk-&gt;chunkType = chunkType;</span><br><span class="line">    chunk-&gt;requestId = <span class="number">0</span>;</span><br><span class="line">    chunk-&gt;copied = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    SIMPLEQ_INSERT_TAIL(&amp;channel-&gt;completeChunks, chunk, pointers);</span><br><span class="line">    <span class="keyword">return</span> UA_STATUSCODE_GOOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>Chunk处理：processChunks()</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Processes chunks and puts them into the payloads queue. Once a final chunk is</span></span><br><span class="line"><span class="comment">* put into the queue, the message is assembled and the callback is called. The</span></span><br><span class="line"><span class="comment">* queue will be cleared for the next message. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> UA_StatusCode</span><br><span class="line"><span class="title function_">processChunks</span><span class="params">(UA_SecureChannel *channel, <span class="type">void</span> *application,</span></span><br><span class="line"><span class="params">              UA_ProcessMessageCallback callback)</span> &#123;</span><br><span class="line">    UA_Chunk *chunk;</span><br><span class="line">    UA_StatusCode res = UA_STATUSCODE_GOOD;</span><br><span class="line">    <span class="comment">// 逐个取出完整的chunk</span></span><br><span class="line">    <span class="keyword">while</span>((chunk = SIMPLEQ_FIRST(&amp;channel-&gt;completeChunks))) &#123;</span><br><span class="line">        <span class="comment">/* Remove from the complete-chunk queue */</span></span><br><span class="line">        <span class="comment">// 把这个chunk从队列中移除</span></span><br><span class="line">        SIMPLEQ_REMOVE_HEAD(&amp;channel-&gt;completeChunks, pointers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check, decrypt and unpack the payload */</span></span><br><span class="line">        <span class="comment">// 检查，解密和解码</span></span><br><span class="line">        <span class="keyword">if</span>(chunk-&gt;messageType == UA_MESSAGETYPE_OPN) &#123;</span><br><span class="line">            <span class="keyword">if</span>(channel-&gt;state != UA_SECURECHANNELSTATE_OPEN &amp;&amp;</span><br><span class="line">              channel-&gt;state != UA_SECURECHANNELSTATE_OPN_SENT &amp;&amp;</span><br><span class="line">              channel-&gt;state != UA_SECURECHANNELSTATE_ACK_SENT)</span><br><span class="line">                res = UA_STATUSCODE_BADINVALIDSTATE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res = unpackPayloadOPN(channel, chunk, application);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(chunk-&gt;messageType == UA_MESSAGETYPE_MSG ||</span><br><span class="line">                  chunk-&gt;messageType == UA_MESSAGETYPE_CLO) &#123;</span><br><span class="line">            <span class="keyword">if</span>(channel-&gt;state == UA_SECURECHANNELSTATE_CLOSED)</span><br><span class="line">                res = UA_STATUSCODE_BADSECURECHANNELCLOSED;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res = unpackPayloadMSG(channel, chunk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chunk-&gt;bytes.data += UA_SECURECHANNEL_MESSAGEHEADER_LENGTH;</span><br><span class="line">            chunk-&gt;bytes.length -= UA_SECURECHANNEL_MESSAGEHEADER_LENGTH;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res != UA_STATUSCODE_GOOD) &#123;</span><br><span class="line">            UA_Chunk_delete(chunk);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Add to the decrypted-chunk queue */</span></span><br><span class="line">        <span class="comment">// 已经解密的数据块添加到 decryptedChunks 队列</span></span><br><span class="line">        SIMPLEQ_INSERT_TAIL(&amp;channel-&gt;decryptedChunks, chunk, pointers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check the resource limits */</span></span><br><span class="line">        channel-&gt;decryptedChunksCount++;</span><br><span class="line">        channel-&gt;decryptedChunksLength += chunk-&gt;bytes.length;</span><br><span class="line">        <span class="keyword">if</span>((channel-&gt;config.localMaxChunkCount != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            channel-&gt;decryptedChunksCount &gt; channel-&gt;config.localMaxChunkCount) ||</span><br><span class="line">          (channel-&gt;config.localMaxMessageSize != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            channel-&gt;decryptedChunksLength &gt; channel-&gt;config.localMaxMessageSize)) &#123;</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETOOLARGE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Waiting for additional chunks */</span></span><br><span class="line">        <span class="comment">// 关键，如果不是最终块，跳过后面的过程并等待新的包</span></span><br><span class="line">        <span class="comment">// 问题：这里是如何驱动的？？？</span></span><br><span class="line">        <span class="keyword">if</span>(chunk-&gt;chunkType == UA_CHUNKTYPE_INTERMEDIATE)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Final chunk or abort. Reset the counters. */</span></span><br><span class="line">        channel-&gt;decryptedChunksCount = <span class="number">0</span>;</span><br><span class="line">        channel-&gt;decryptedChunksLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort the message, remove all decrypted chunks</span></span><br><span class="line"><span class="comment">        * <span class="doctag">TODO:</span> Log a warning with the error code */</span></span><br><span class="line">        <span class="keyword">if</span>(chunk-&gt;chunkType == UA_CHUNKTYPE_ABORT) &#123;</span><br><span class="line">            <span class="keyword">while</span>((chunk = SIMPLEQ_FIRST(&amp;channel-&gt;decryptedChunks))) &#123;</span><br><span class="line">                SIMPLEQ_REMOVE_HEAD(&amp;channel-&gt;decryptedChunks, pointers);</span><br><span class="line">                UA_Chunk_delete(chunk);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The decrypted queue contains a full message. Process it. */</span></span><br><span class="line">        <span class="comment">// 组装块，处理+发送！</span></span><br><span class="line">        UA_assert(chunk-&gt;chunkType == UA_CHUNKTYPE_FINAL);</span><br><span class="line">        res = assembleProcessMessage(channel, application, callback);</span><br><span class="line">        UA_CHECK_STATUS(res, <span class="keyword">return</span> res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UA_STATUSCODE_GOOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组装块：assembleProcessMessage()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> UA_StatusCode</span><br><span class="line"><span class="title function_">assembleProcessMessage</span><span class="params">(UA_SecureChannel *channel, <span class="type">void</span> *application,</span></span><br><span class="line"><span class="params">                    UA_ProcessMessageCallback callback)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得解密队列的第一个块</span></span><br><span class="line">    UA_Chunk *chunk = SIMPLEQ_FIRST(&amp;channel-&gt;decryptedChunks);</span><br><span class="line">    UA_assert(chunk != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    UA_StatusCode res = UA_STATUSCODE_GOOD;</span><br><span class="line">    <span class="comment">// 如果是Final块，那么就可以直接调用callback了</span></span><br><span class="line">    <span class="keyword">if</span>(chunk-&gt;chunkType == UA_CHUNKTYPE_FINAL) &#123;</span><br><span class="line">        SIMPLEQ_REMOVE_HEAD(&amp;channel-&gt;decryptedChunks, pointers);</span><br><span class="line">        UA_assert(chunk-&gt;chunkType == UA_CHUNKTYPE_FINAL);</span><br><span class="line">        res = callback(application, channel, chunk-&gt;messageType,</span><br><span class="line">                    chunk-&gt;requestId, &amp;chunk-&gt;bytes);</span><br><span class="line">        UA_Chunk_delete(chunk);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是Final块，那么获取到requestId等信息，用于检查解密队列中的其他块</span></span><br><span class="line">    UA_UInt32 requestId = chunk-&gt;requestId;</span><br><span class="line">    UA_MessageType messageType = chunk-&gt;messageType;</span><br><span class="line">    UA_ChunkType chunkType = chunk-&gt;chunkType;</span><br><span class="line">    UA_assert(chunkType == UA_CHUNKTYPE_INTERMEDIATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Q：怎么保证解密队列里都是这个requestId的块？如果有多个client连接并分包发送，怎么办？？？</span></span><br><span class="line">    <span class="comment">// A：channel是一个client独有的。顺序是通过TCP的消息按序到达实现的。</span></span><br><span class="line">    <span class="type">size_t</span> messageSize = <span class="number">0</span>;</span><br><span class="line">    SIMPLEQ_FOREACH(chunk, &amp;channel-&gt;decryptedChunks, pointers) &#123;</span><br><span class="line">        <span class="comment">/* Consistency check */</span></span><br><span class="line">        <span class="keyword">if</span>(requestId != chunk-&gt;requestId)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADINTERNALERROR;</span><br><span class="line">        <span class="keyword">if</span>(chunkType != chunk-&gt;chunkType &amp;&amp; chunk-&gt;chunkType != UA_CHUNKTYPE_FINAL)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line">        <span class="keyword">if</span>(chunk-&gt;messageType != messageType)</span><br><span class="line">            <span class="keyword">return</span> UA_STATUSCODE_BADTCPMESSAGETYPEINVALID;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Sum up the lengths */</span></span><br><span class="line">        messageSize += chunk-&gt;bytes.length;</span><br><span class="line">        <span class="keyword">if</span>(chunk-&gt;chunkType == UA_CHUNKTYPE_FINAL)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate memory for the full message */</span></span><br><span class="line">    <span class="comment">// 用计算的大小分配空间</span></span><br><span class="line">    UA_ByteString payload;</span><br><span class="line">    res = UA_ByteString_allocBuffer(&amp;payload, messageSize);</span><br><span class="line">    UA_CHECK_STATUS(res, <span class="keyword">return</span> res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assemble the full message */</span></span><br><span class="line">    <span class="comment">// 合并data</span></span><br><span class="line">    <span class="type">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        chunk = SIMPLEQ_FIRST(&amp;channel-&gt;decryptedChunks);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;payload.data[offset], chunk-&gt;bytes.data, chunk-&gt;bytes.length);</span><br><span class="line">        offset += chunk-&gt;bytes.length;</span><br><span class="line">        SIMPLEQ_REMOVE_HEAD(&amp;channel-&gt;decryptedChunks, pointers);</span><br><span class="line">        UA_ChunkType ct = chunk-&gt;chunkType;</span><br><span class="line">        UA_Chunk_delete(chunk);</span><br><span class="line">        <span class="keyword">if</span>(ct == UA_CHUNKTYPE_FINAL)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process the assembled message */</span></span><br><span class="line">    res = callback(application, channel, messageType, requestId, &amp;payload);</span><br><span class="line">    UA_ByteString_clear(&amp;payload);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="两个处理方案的区别："><a href="#两个处理方案的区别：" class="headerlink" title="两个处理方案的区别："></a>两个处理方案的区别：</h2><ol>
<li>接收包上：我们的方案是以获取完整包为最优先，逻辑是获取完整包，完毕后如果有剩下的数据，继续尝试获取对于它获得完整包。open62541是每次读满缓存区，先检查有没有之前获得的不完整的包，如果有就加到缓存区前面，形成完整包并先处理。然后尝试获取完整包并处理，最后看看缓存区后面有没有不完整的包</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/" data-id="cm3e9rhx8000070vc3jr23fkj" data-title="OPCUA open62541-包接收流程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/11/09/Mybatis/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Mybatis
        
      </div>
    </a>
  
  
    <a href="/2024/11/05/OPCUA-open62541%E8%AE%A2%E9%98%85%E5%8E%9F%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">OCPUA open62541-订阅监视</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LCR119/">LCR119</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/">LeetCode101</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E5%9B%9E%E6%BA%AF/">回溯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">深度优先搜索</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Makefile/">Makefile</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/REDIS/">REDIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/MIT-6824/">MIT-6824</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/TypeScript/">TypeScript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/">baosight</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/OPC-UA/">OPC_UA</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/">网络系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/">日常开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/ImageMatchingfromHandcraftedtoDeepFeatures-ASurvey/">ImageMatchingfromHandcraftedtoDeepFeatures:ASurvey</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/">分治</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">常用算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">软件设计</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/%E6%8F%8F%E8%BF%B0%E4%B8%8E%E9%9D%A2%E8%AF%95/">描述与面试</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/">数据库基础</a>
          </li>
        
          <li>
            <a href="/2024/11/13/Spring-%E4%BA%8B%E5%8A%A1/">Spring-事务</a>
          </li>
        
          <li>
            <a href="/2024/11/12/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a>
          </li>
        
          <li>
            <a href="/2024/11/09/Mybatis/">Mybatis</a>
          </li>
        
          <li>
            <a href="/2024/11/07/OPCUA-open62541%E5%8C%85%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/">OPCUA open62541-包接收流程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>