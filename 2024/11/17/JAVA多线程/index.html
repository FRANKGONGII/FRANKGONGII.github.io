<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>多线程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="基础知识线程创建与执行继承Thread并重新run方法 示例12345678910111213public class mThread extends Thread &#123;    @Override    public void run() &#123;        &#x2F;&#x2F; 你的逻辑    &#125;&#125;&#x2F;** 调用* mThread m &#x3D; new Thread();* m.st">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="http://example.com/2024/11/17/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="基础知识线程创建与执行继承Thread并重新run方法 示例12345678910111213public class mThread extends Thread &#123;    @Override    public void run() &#123;        &#x2F;&#x2F; 你的逻辑    &#125;&#125;&#x2F;** 调用* mThread m &#x3D; new Thread();* m.st">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-11-17T15:20:33.000Z">
<meta property="article:modified_time" content="2024-11-27T15:09:27.072Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JAVA多线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/17/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-11-17T15:20:33.000Z" itemprop="datePublished">2024-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      多线程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="线程创建与执行"><a href="#线程创建与执行" class="headerlink" title="线程创建与执行"></a>线程创建与执行</h2><h3 id="继承Thread并重新run方法"><a href="#继承Thread并重新run方法" class="headerlink" title="继承Thread并重新run方法"></a>继承Thread并重新run方法</h3><ul>
<li>示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 你的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 调用</span></span><br><span class="line"><span class="comment">* mThread m = new Thread();</span></span><br><span class="line"><span class="comment">* m.start()；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>调用start方法后线程处于就绪状态，只有获取到CPU资源后才处于运行状态，run方法执行完后处于终止状态</li>
<li>使用继承方法的好处是获取当前线程只需要使用this，设置线程内局部变量也比较方便。但是受到没有多线程的限制</li>
</ul>
<h3 id="实现Runnable接口的run方法"><a href="#实现Runnable接口的run方法" class="headerlink" title="实现Runnable接口的run方法"></a>实现Runnable接口的run方法</h3><ul>
<li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mThreadTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 你的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 调用</span></span><br><span class="line"><span class="comment">* mThreadTask m = new RunnableTask();</span></span><br><span class="line"><span class="comment">* new Thread(m).start();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>继承Runnable后线程内只能使用主线程内声明为final的变量，但是可以继承其他类</li>
</ul>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><ul>
<li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mCallTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 你的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 调用</span></span><br><span class="line"><span class="comment">* FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(new CallerTask());</span></span><br><span class="line"><span class="comment">* new Thread(ft).start();</span></span><br><span class="line"><span class="comment">* try &#123;</span></span><br><span class="line"><span class="comment">*   String res = ft.get();</span></span><br><span class="line"><span class="comment">* &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>使用时是先创建FutureTask对象，然后使用这个对象创建一个线程，然后通过get()方法等待任务执行完成并获取返回值</li>
<li>这种方法好处是可以获取线程方法执行返回值</li>
</ul>
<h2 id="线程的通知与等待"><a href="#线程的通知与等待" class="headerlink" title="线程的通知与等待"></a>线程的通知与等待</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><ul>
<li>当一个线程调用一个共享变量的wait()函数时，改调用线程会被阻塞挂起 - 直到该共享变量的notify()方法被调用或该线程的interrupt()方法被调用（会抛出中断异常）</li>
<li>wait()方法的一个典型使用是避免虚假唤醒：也就是没有一个线程没有被通知或者中断就由挂起变成了可以运行状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    <span class="keyword">while</span>(condition) &#123;</span><br><span class="line">        obj.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意wait()方法只会释放当前共享变量的锁，如果该线程还持有其他共享变量的锁，不会被释放</li>
<li>wait(long timeout)：如果没有在限时内被唤醒，会因为超时返回</li>
</ul>
<h3 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h3><ul>
<li>一个线程调用共享对象notify()方法后，会唤醒一个在该对象上调用了wait()的线程（如果有多个，随机）。被唤醒的线程要等待唤醒它的线程释放锁，才能最终继续执行。当前线程必须获取到对象上的锁才能调用notify()方法</li>
</ul>
<h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h3><ul>
<li>区别是会唤醒所有线程，只是区别是谁先获取到锁。而且notifyAll()后如果一个线程调用了wait方法而被放入阻塞集合，则不会被再唤醒</li>
</ul>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ul>
<li>场景：多个线程加载资源，等待多个线程全部加载完毕再汇总处理。</li>
<li>join()是由Thread类提供的，而不是Object类</li>
<li>主线程在调用threadx.join()后被阻塞，当threadx执行完毕后才会返回，如果这时候主线程被中断，会抛出中断异常。</li>
</ul>
<h2 id="线程的睡眠"><a href="#线程的睡眠" class="headerlink" title="线程的睡眠"></a>线程的睡眠</h2><h3 id="sleep-long-millis"><a href="#sleep-long-millis" class="headerlink" title="sleep(long millis)"></a>sleep(long millis)</h3><ul>
<li>Thread类提供。在休眠期间让出指定时间的执行权，不参与CPU调度，但是不会释放锁。如果睡眠期间被中断会抛出中断异常。</li>
</ul>
<h2 id="让出CPU"><a href="#让出CPU" class="headerlink" title="让出CPU"></a>让出CPU</h2><h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><ul>
<li>正常情况下，当线程的时间使用完后，才会进行下一轮的线程调度。yield方法是告诉线程调度器可以不管自己时间片中的剩余部分，直接开始下一轮线程调度。当调用yield方法后，当前线程让出CPU，处于就绪态，然后取出就绪队列里面优先级最高的线程。</li>
</ul>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h3><ul>
<li>被调用该方法只是设置了一个中断标志为true，实际并不会被中断，仍然可以继续执行。但如果这个线程被阻塞挂起了，就会因为抛出中断异常而被返回。</li>
</ul>
<h3 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a>isInterrupted()</h3><ul>
<li>检查当前线程是否被中断，如果是返回true</li>
</ul>
<h3 id="static-interrupted"><a href="#static-interrupted" class="headerlink" title="static interrupted()"></a>static interrupted()</h3><ul>
<li>区别是如果被中断，会清除中断标志。检查的是当前调用线程的中断标志，而不是调用方法对象的标志</li>
<li>源码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> currentThread().isInterrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="优雅的杀死线程"><a href="#优雅的杀死线程" class="headerlink" title="优雅的杀死线程"></a>优雅的杀死线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">while</span>(!Thread.currentThread().isInterrupted() &amp;&amp; condition not satisfied) &#123;</span><br><span class="line">     <span class="comment">// do work</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">     <span class="comment">// thread was interrupted while wait or sleep</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// cleanup work, if necessary</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞过程中提前满足了激活条件"><a href="#阻塞过程中提前满足了激活条件" class="headerlink" title="阻塞过程中提前满足了激活条件"></a>阻塞过程中提前满足了激活条件</h3><ul>
<li>例如我们让一个线程sleep以等待某个条件，但是不到sleep的设置时间就满足了条件，这时候我们可以调用interrupted()方法，强制抛出异常以返回。</li>
<li>实例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadx.start()；</span><br><span class="line"><span class="comment">// 满足条件</span></span><br><span class="line">threadx.interrupted();</span><br><span class="line">threadx.join();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>TODO: sleep打断和notify有什么区别？</p>
<h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><ul>
<li>让出CPU时要保存现场</li>
<li>时机：当前时间片用完，处于就绪态 &#x2F; 被中断</li>
</ul>
<h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><ul>
<li><p>多个线程因为争取资源产生的相互等待的现象</p>
</li>
<li><p>产生条件：</p>
<ol>
<li>互斥：资源同时只能有一个线程使用</li>
<li>请求并持有：一个线程请求新的资源被阻塞，但是又不会释放自己的资源</li>
<li>不可剥夺：线程获取到资源后，在使用完毕之前不会被抢占</li>
<li>环路等待：发生死锁的时候存在一个线程-资源的环形等待链</li>
</ol>
</li>
<li><p>产生死锁的例子：<br>休眠时保证后抢占CPU的线程能拿到资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object A;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object B;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(A) &#123;</span><br><span class="line">          <span class="comment">// get A</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException E) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wait for B</span></span><br><span class="line">        <span class="keyword">synchronized</span>(B) &#123;</span><br><span class="line">          <span class="comment">// get B</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(B) &#123;</span><br><span class="line">          <span class="comment">// get B</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException E) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wait for A</span></span><br><span class="line">        <span class="keyword">synchronized</span>(A) &#123;</span><br><span class="line">          <span class="comment">// get A</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免死锁：<strong>只能破坏请求持有和环路等待</strong></p>
<ul>
<li>方法：资源申请的有序性<ul>
<li>资源以一个有序的顺序请求资源（安全序列），例如上面的例子：可以让A，B线程请求的顺序一致 </li>
<li>更通用的是银行家算法，它通过合理分配资源，并在每次分配之后进行安全性检查。缺点是需要知道每个进程的最大需求</li>
</ul>
</li>
<li>方法：静态分配（破坏请求保持）</li>
</ul>
</li>
<li><p>检查接触死锁</p>
<ul>
<li>检查：<ol>
<li>超时分析</li>
<li>等待图分析：进程和资源的等待关系</li>
</ol>
</li>
<li>解除：<ol>
<li>终止进程</li>
<li>进程超时释放资源</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a>守护线程和用户线程</h2><ul>
<li>daemon（守护线程），user（用户线程）</li>
<li>区别是JVM在最后一个非守护线程接受后会正常退出，不管有没有守护线程</li>
<li>设置成守护线程：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadx.setDaemon(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_69519887/article/details/141071290">https://blog.csdn.net/m0_69519887/article/details/141071290</a></p>
<ul>
<li><p>创建一个变量，每个线程每次访问的是自己线程的变量 – 线程本地变量。<br>多个线程操作threadlocal变量实际是操作自己本地内存内的变量</p>
</li>
<li><p>threadlocl是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry（threadlocl,value），虽然不同的线程之间threadlocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，<br>也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。</p>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">localVar.get(); <span class="comment">// 取得值</span></span><br><span class="line">localVar.set(<span class="string">&quot;text&quot;</span>); <span class="comment">// 设置值</span></span><br><span class="line">localVar.remove(); <span class="comment">// 移出</span></span><br></pre></td></tr></table></figure></li>
<li><p>原理</p>
<ul>
<li>Thread中有两个变量threadLocals和inheritableThreadLocals，他们都是ThreadLocalMap类的对象。<br>每个线程的本地变量不是存在ThreadLocal实例里面，而是在调用线程的threadLocals变量里面</li>
<li>get()，set()，remove()都是类似的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1、获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//2、获取当前线程的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//3、如果map数据不为空，</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//3.1、获取threalLocalMap中存储的值</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是数据为null，则初始化，初始化的结果，TheralLocalMap中存放key值为threadLocal，值为null</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Entry：ThreadLocal类和对应的值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存储的每个元素--Entry</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        </span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始容量--必须是2的整数幂</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存放数据的Table，长度也必须是2的整数幂</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 数组内已使用的长度，即Entrys的个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 进行扩容的阈值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为什么要remove？由于ThreadLoaclMap的生命周期和Thread一样长，如果没有手动删除对应的Key就会导致内存泄漏。</li>
</ul>
</li>
<li><p>InheritableThreadLocal：让子线程访问父线程内的值，每次初始化都会复制一份父类的ThreadLocal</p>
</li>
</ul>
<h1 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h1><ul>
<li>内存可见性问题：<ul>
<li>每个线程占用一个CPU核，每个核有自己的cache，一般还有一个所有核共享的cache，这分别对应了Java的私有内存和主内存<br>当一个线程操作共享变量时，首先从主内存复制到工作内存，处理完之后更新到主存</li>
<li>两段cache可能导致的内存不可见问题：共享变量被一个线程修改了，但是没有从主内存中获取最新的值，而是命中了工作内存中的一级缓存的值</li>
</ul>
</li>
<li>操作原子性：<ul>
<li>看起来是一句的代码，编译之后可能变为多个，在多线程下不一定能一起执行，导致出错。例如x++</li>
</ul>
</li>
</ul>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul>
<li>内置性原子锁，每个对象都可以把他当做一个同步锁使用。是一个排它锁，线程在进入synchronized代码块前会获取锁，其他线会被阻塞</li>
<li>内存语义：进入synchronized内存块时把块内变量从线程的工作内存中清除，这样块内使用就是直接从主存里面取。退出synchronized块的语义是把块内修改强制刷新到主存</li>
<li>注意synchronized会引起线程上下文切换，以及用户态到内核态的切换，有开销</li>
<li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li>使用锁太笨重，有上下文切换开销。volatile关键字保证对一个变量的更新立刻对其他线程可见。- <strong>内存可见性</strong></li>
<li>当一个变量声明为volatile时，线程写入该变量会直接刷到主存，读取该变量也会直接从主存读取，而不是使用工作线程中的值</li>
<li>何时时候使用volatile关键字？<ol>
<li>写入变量不依赖当前值：例如x++，volatile不能保证原子性，就可能出错：x++包括获取-计算-写入。两个变量读到了最新值，但是一起去改了，导致比预期值少。</li>
<li>读写变量值时没有加锁：加锁是比volatile更安全的方法</li>
</ol>
</li>
<li>实例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h2><ul>
<li>一系列操作，要么全部执行，要么全部不执行</li>
<li>不安全的操作：翻译为汇编就是多个指令  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">    value++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如何保证原子性？<ol>
<li>使用锁：保证线程安全：内存可见+原子性 – 并发性降低</li>
<li>CAS算法实现的原子性操作类</li>
</ol>
</li>
</ul>
<h2 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cy973071263/article/details/104422594">https://blog.csdn.net/cy973071263/article/details/104422594</a></p>
<ul>
<li>CAS是compare and swap的简称，有三个核心参数<ul>
<li>V内存中地址存放的实际值：通过对象内存地址和对象内目标变量偏移量获取</li>
<li>O预期值</li>
<li>N新值</li>
<li>操作过程：最开始VO是相等的，要进行CAS操作时，先判断VO是不是相等，若相等，说明没有V中的值还没有被其他线程更改，这时就可以将N中的值替换到V中。若不相等表明N中的值已经被其他的线程所更改，这时直接将N中的值返回即可。多个线程同时CAS，只有一个能成功并更新为V，其他线程可以不断CAS，也可以挂起等待</li>
</ul>
</li>
<li>引入CAS可能产生的问题 - ABA问题<ul>
<li>描述：ABA 问题出现在以下场景中：<ol>
<li>线程T1 读取了某个共享变量的值为 A。</li>
<li>线程T2 在此期间将该值改成了 B，然后又改回了 A。</li>
<li>当线程 T1 再次检查时，发现值仍是 A，认为它没有被修改过，从而错误地进行更新。</li>
</ol>
</li>
<li>虽然值在表面上没有变化（依然是 A），但实际上中间已经经历过了其他线程的修改。这种情况可能会导致逻辑错误，尤其是在依赖值的不变性的场景中。 </li>
<li>解决方法：ABA产生的原因是环形转换，也就是A-B-A。JDK的AtomicStampedReference的解决方法是为每个变量在配置一个时间戳属性<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABATest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化值为100，版本号为1</span></span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; atomicStampedRef = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] stamp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">initialRef</span> <span class="operator">=</span> atomicStampedRef.get(stamp);<span class="comment">// 返回值是val，stamp通过数组获取</span></span><br><span class="line">        System.out.println(<span class="string">&quot;初始值: &quot;</span> + initialRef + <span class="string">&quot;, 初始版本号: &quot;</span> + stamp[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟 ABA 问题</span></span><br><span class="line">        atomicStampedRef.compareAndSet(<span class="number">100</span>, <span class="number">200</span>, stamp[<span class="number">0</span>], stamp[<span class="number">0</span>] + <span class="number">1</span>); <span class="comment">// 100 -&gt; 200</span></span><br><span class="line">        atomicStampedRef.compareAndSet(<span class="number">200</span>, <span class="number">100</span>, stamp[<span class="number">0</span>] + <span class="number">1</span>, stamp[<span class="number">0</span>] + <span class="number">2</span>); <span class="comment">// 200 -&gt; 100</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试更新</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isUpdated</span> <span class="operator">=</span> atomicStampedRef.compareAndSet(<span class="number">100</span>, <span class="number">300</span>, stamp[<span class="number">0</span>], stamp[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否更新成功: &quot;</span> + isUpdated);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前值: &quot;</span> + atomicStampedRef.getReference() + <span class="string">&quot;, 当前版本号: &quot;</span> + atomicStampedRef.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>compare等一系列方法的伪代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == expect) &#123;</span><br><span class="line">    <span class="built_in">this</span> = update</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>cmpxchgl 指令是包含在 x86 架构及 IA-64 架构中的一个原子条件指令，在我们的例子中，它会首先比较 dest 指针指向的内存值是否和 compare_value 的值相等，如果相等，则双向交换 dest 与 exchange_value，否则就单方面地将 dest 指向的内存值交给 &#96;&#96;exchange_value。这条指令完成了整个 CAS 操作，因此它也被称为 CAS 指令。事实上，现代指令集架构基本上都会提供 CAS 指令，例如 x86 和 IA-64 架构中的 cmpxchgl 指令和 comxchgq 指令，sparc 架构中的 cas 指令和 casx 指令等等。不管是 Hotspot 中的 Atomic::cmpxchg 方法，还是 Java 中的 compareAndSwapInt 方法，它们本质上都是对相应平台的 CAS 指令的一层简单封装。CAS 指令作为一种硬件原语，有着天然的原子性，这也正是 CAS 的价值所在。</li>
</ul>
</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul>
<li>当一个线程尝试获取锁时，如果锁已被其他线程占用，它不会进入阻塞状态，而是会一直循环（自旋）尝试获取锁。<br>自旋锁的核心机制往往依赖于 CAS 来实现对锁状态的检查和更新。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="comment">// 原子类，内部是volatile和CAS，线程安全。设置false是代表锁空闲</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不断尝试获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!lock.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>特点：<ol>
<li>如果锁等待时间较短，避免了线程切换的开销。</li>
<li>如果锁等待时间较长，会浪费大量 CPU 资源。</li>
</ol>
</li>
</ul>
<h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/unsafe.html#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C">https://javaguide.cn/java/basis/unsafe.html#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C</a><br><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/unsafe.html#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C">https://javaguide.cn/java/basis/unsafe.html#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C</a></p>
<ul>
<li>主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等。都是native方法，使用JNI的方法访问本地C++实现库</li>
<li>使用<ul>
<li><code>Unsafe.getUnsafe()</code>并不能使用让我们获得Unsafe对象<ul>
<li>Unsafe部分源码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 单例对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@CallerSensitive</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">          <span class="comment">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法</span></span><br><span class="line">          <span class="keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ```  </span><br><span class="line">  + 我们使用自己的类，然后定义变量，使用的AppClassLoader加载，而不是Bootstarp类，就会抛出错误</span><br><span class="line">+ 我们可以利用反射实例化Unsafe</span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUnSafe</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> stateOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> state;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用反射获取theUnsafe</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置可存取</span></span><br><span class="line">        field.setAccessilbe(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取值</span></span><br><span class="line">        unsafe = (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取偏移量</span></span><br><span class="line">        stateOffset = unsafe.objectFieldOffset(TestUnSafe.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">TestUnSafe</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestUnSafe</span>();</span><br><span class="line">      <span class="type">Boolean</span> <span class="variable">res</span> <span class="operator">=</span> unsafe.compareAndSwapInt(test, stateOffset, <span class="number">0</span> ,<span class="number">1</span>); <span class="comment">// 如果为0，修改为1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Unsafe的作用"><a href="#Unsafe的作用" class="headerlink" title="Unsafe的作用"></a>Unsafe的作用</h3><ul>
<li><p>内存操作</p>
<ul>
<li>API<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配新的本地空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//重新调整内存空间的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">reallocateMemory</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//将内存设置为指定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">copyMemory</span><span class="params">(Object srcBase, <span class="type">long</span> srcOffset,Object destBase, <span class="type">long</span> destOffset,<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//清除内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">freeMemory</span><span class="params">(<span class="type">long</span> address)</span>;</span><br></pre></td></tr></table></figure></li>
<li>分配的是堆外内存，不能被GC，因此要手动释放。一般在try-catch结构中使用。堆外内存可以减少GC的停顿；提升程序IO的性能，因为I&#x2F;O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>
</ul>
</li>
<li><p>内存屏障</p>
<ul>
<li><p>在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。Unsafe引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：如果没有内存屏障，不能获取到flag的值的变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChangeThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">/**volatile**/</span> <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;subThread change flag to:&quot;</span> + flag);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">ChangeThread</span> <span class="variable">changeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeThread</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(changeThread).start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> changeThread.isFlag();</span><br><span class="line">        unsafe.loadFence(); <span class="comment">//加入读内存屏障</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;detected flag changed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;main thread end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>对象操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在对象的指定偏移地址获取一个对象引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">getObject</span><span class="params">(Object o, <span class="type">long</span> offset)</span>;</span><br><span class="line"><span class="comment">//在对象指定偏移地址写入一个对象引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object x)</span>;</span><br><span class="line"><span class="comment">// 还有很多，一个例子可以见前</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回数组中第一个元素的偏移地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">arrayBaseOffset</span><span class="params">(Class&lt;?&gt; arrayClass)</span>;</span><br><span class="line"><span class="comment">//返回数组中一个元素占用的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">arrayIndexScale</span><span class="params">(Class&lt;?&gt; arrayClass)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CAS操作，见前</p>
</li>
<li><p>线程调度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Object thread)</span>;</span><br><span class="line"><span class="comment">//阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">boolean</span> isAbsolute, <span class="type">long</span> time)</span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorEnter</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorExit</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">tryMonitorEnter</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><ul>
<li>java会对不存在数据依赖性的指令重排序，多线程情况下可能有问题<br>在下面这个例子中，如果1，2顺序被重排，就会不符合预期<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        System.out.println(num + num);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">      ready = <span class="literal">true</span>; <span class="comment">// 1</span></span><br><span class="line">      num = <span class="number">2</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用volatile可以避免这个问题，写volatile前的操作不会被排到写之后，读之后的不会被排到读之前</li>
</ul>
<h2 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h2><ul>
<li>产生原因：– 本质上就是程序局部性在多线程下的问题？<ul>
<li>cache操作的单位是内存块（缓存行），一个内存块可能包含多个变量</li>
<li>如果多个线程同时操作处于同一个缓存行中的不同变量，会导致缓存行内变量失效，从而使得缓存失效</li>
</ul>
</li>
<li>避免伪共享：<ul>
<li>字节填充：把一个对象或者基本类型填充到一个类内，大小等于缓存行大小即可。注意考虑类对象的对象头还有8字节。</li>
<li>可以直接使用<code>@sun.misc.Contented</code>修饰类和变量来实现字节填充</li>
</ul>
</li>
</ul>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><ul>
<li>悲观锁更新的方式认为：在更新数据的时候大概率会有其他线程去争夺共享资源<ul>
<li>悲观锁的做法是：第一个获取资源的线程会将资源锁定起来，其他没争夺到资源的线程只能进入阻塞队列，等第一个获取资源的线程释放锁之后，这些线程才能有机会重新争夺资源。</li>
<li>synchronized就是java中悲观锁的典型实现，synchronized使用起来非常简单方便，但是会使没争抢到资源的线程进入阻塞状态，线程在阻塞状态和Runnable状态之间切换效率较低（比较慢）。比如更新操作其实是非常快的，这种情况下还用synchronized将其他线程都锁住了，线程从Blocked状态切换回Runnable华的时间可能比更新操作的时间还要长。 </li>
<li>数据库查询时for update也是悲观锁</li>
</ul>
</li>
<li>乐观锁更新方式认为:在更新数据的时候其他线程争抢这个共享变量的概率非常小<ul>
<li>乐观锁的做法是：更新数据的时候不会对共享数据加锁。但是在正式更新数据之前会检查数据是否被其他线程改变过，如果未被其他线程改变过就将共享变量更新成最新值，如果发现共享变量已经被其他线程更新过了，就重试，直到成功为止。</li>
<li>CAS机制就是乐观锁的典型实现。</li>
</ul>
</li>
<li>一个乐观锁和悲观锁的例子<ul>
<li>悲观锁：多个线程执行此方法，只有一个会成功，其余被阻塞<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EntryObject</span> <span class="variable">entry</span> <span class="operator">=</span> query(<span class="string">&quot;select * from table1 where id = #&#123;id&#125; for update&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>乐观锁：添加一个version字段，类似CAS<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EntryObject</span> <span class="variable">entry</span> <span class="operator">=</span> query(<span class="string">&quot;select * from table1 where id = #&#123;id&#125; for update&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> update(<span class="string">&quot;update table1 set name = #&#123;name&#125;, version = #&#123;version&#125; + 1 where id = #&#123;id&#125; and #&#123;version&#125;&quot;</span>)</span><br><span class="line"><span class="comment">// 通过count可以实现重试逻辑</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><ul>
<li>公平锁：线程获取锁的顺序是根据请求时间决定的，先来先到</li>
<li>非公平锁：不一定先到先得，允许抢占</li>
<li>创建(非)公平锁：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentranLock</span> <span class="variable">pairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentranLock</span>(<span class="literal">true</span>); <span class="comment">// 公平锁</span></span><br><span class="line"><span class="type">ReentranLock</span> <span class="variable">pairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentranLock</span>(<span class="literal">false</span>); <span class="comment">// 非公平锁</span></span><br></pre></td></tr></table></figure></li>
<li>公平锁会有额外的开销</li>
</ul>
<h2 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h2><ul>
<li>独占锁：一次只有一个线程持有：悲观锁，ReentranLock</li>
<li>共享锁：可以有多个线程持有：乐观锁，ReadWriteLock</li>
</ul>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><ul>
<li>当前持有锁的线程能不能再次获取锁</li>
<li>内部维护一个标识，记录被那个线程占用已经占用次数，如果为0就就可以唤醒线程</li>
</ul>
<h2 id="自旋锁-1"><a href="#自旋锁-1" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul>
<li>获取不到锁的时候不马上阻塞自己，在不放弃CPU的情况下多次尝试获取锁</li>
<li>可以避免用户态到内核态的切换挂起过程</li>
<li>一个简单的自旋锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 循环检测尝试获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!tryLock())&#123;</span><br><span class="line">            <span class="comment">// doSomething...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁，成功返回true，失败返回false</span></span><br><span class="line">        <span class="keyword">return</span> available.compareAndSet(<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!available.compareAndSet(<span class="literal">true</span>,<span class="literal">false</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;释放锁失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><h2 id="AtomicXX：Integer，Long，Boolean等等"><a href="#AtomicXX：Integer，Long，Boolean等等" class="headerlink" title="AtomicXX：Integer，Long，Boolean等等"></a>AtomicXX：Integer，Long，Boolean等等</h2><p>这些类的实现类似，以AtomicLong为例。</p>
<h3 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h3><ul>
<li>这是原子性递增或递减类，内部是用Unsafe实现的</li>
<li>源码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicLong</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> ..L;</span><br><span class="line">  <span class="comment">// 获取Unsafe实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// value的偏移量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      valueOffset = unsafe.objectFieldOffset(AtomicLong.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 变量值，保证内存可见性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>相关函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// AtomicLong实例的引用，偏移量，要设置的值</span></span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddLong(<span class="built_in">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getAndAddLong</span><span class="params">(Object paramObject, <span class="type">long</span> paramLong1, <span class="type">long</span> paramLong2)</span> &#123;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    l = getLongvolatile(paramObject, paramLong1);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!compareAndSwapLong(paramObject, paramLong1, l ,<span class="number">1</span> + paramLong2));</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">long</span> except, <span class="type">long</span> update)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, except, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="XXAddr"><a href="#XXAddr" class="headerlink" title="XXAddr"></a>XXAddr</h2><ul>
<li>高并发下AtomicXX有性能问题（自旋导致的CPU大量占用），Java8下有高性能下性能更好地XXAddr类。</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/17/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="cm3lu7kni00000wvca0reciry" data-title="多线程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/11/28/MySql/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          MySql
        
      </div>
    </a>
  
  
    <a href="/2024/11/17/RabbitMQ/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">RabbitMQ</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LCR119/">LCR119</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/">LeetCode101</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E5%9B%9E%E6%BA%AF/">回溯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode101/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">深度优先搜索</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Makefile/">Makefile</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/REDIS/">REDIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/">Dubbo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/MIT-6824/">MIT-6824</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RabbitMQ/">RabbitMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/TypeScript/">TypeScript</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/">baosight</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0/baosight/OPC-UA/">OPC_UA</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/">网络系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/">日常开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/ImageMatchingfromHandcraftedtoDeepFeatures-ASurvey/">ImageMatchingfromHandcraftedtoDeepFeatures:ASurvey</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/">分治</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">常用算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">软件设计</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/%E6%8F%8F%E8%BF%B0%E4%B8%8E%E9%9D%A2%E8%AF%95/">描述与面试</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/28/MySql/">MySql</a>
          </li>
        
          <li>
            <a href="/2024/11/17/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
          </li>
        
          <li>
            <a href="/2024/11/17/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2024/11/16/Dubbo/">Dubbo</a>
          </li>
        
          <li>
            <a href="/2024/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/">数据库基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>